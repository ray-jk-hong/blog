<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>内存带宽(resctrl) | ray.jk.hong</title><meta name="author" content="ray.jk.hong"><meta name="copyright" content="ray.jk.hong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="以下是Documentation&#x2F;x86&#x2F;resctrl.rst翻译： 介绍英特尔将此功能称为”英特尔资源导向技术(Resource Director Technology)、(Intel(R) RDT)”。AMD将此功能称为AMD QoS。 此功能由CONFIG_X86_CPU_RESCTRL和x86的&#x2F;proc&#x2F;cpuinfo标志位启用。标志位：          RDT (Resource">
<meta property="og:type" content="article">
<meta property="og:title" content="内存带宽(resctrl)">
<meta property="og:url" content="https://ray-jk-hong.github.io/2025/07/25/linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%B8%A6%E5%AE%BD/index.html">
<meta property="og:site_name" content="ray.jk.hong">
<meta property="og:description" content="以下是Documentation&#x2F;x86&#x2F;resctrl.rst翻译： 介绍英特尔将此功能称为”英特尔资源导向技术(Resource Director Technology)、(Intel(R) RDT)”。AMD将此功能称为AMD QoS。 此功能由CONFIG_X86_CPU_RESCTRL和x86的&#x2F;proc&#x2F;cpuinfo标志位启用。标志位：          RDT (Resource">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ray-jk-hong.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-07-25T10:35:53.573Z">
<meta property="article:modified_time" content="2025-07-25T10:35:53.573Z">
<meta property="article:author" content="ray.jk.hong">
<meta property="article:tag" content="内存管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ray-jk-hong.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "内存带宽(resctrl)",
  "url": "https://ray-jk-hong.github.io/2025/07/25/linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%B8%A6%E5%AE%BD/",
  "image": "https://ray-jk-hong.github.io/img/butterfly-icon.png",
  "datePublished": "2025-07-25T10:35:53.573Z",
  "dateModified": "2025-07-25T10:35:53.573Z",
  "author": [
    {
      "@type": "Person",
      "name": "ray.jk.hong",
      "url": "https://ray-jk-hong.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="https://ray-jk-hong.github.io/2025/07/25/linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%B8%A6%E5%AE%BD/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '内存带宽(resctrl)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="/js/bandev.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/blog/"></a><a class="nav-page-title" href="/blog/"><span class="site-name">内存带宽(resctrl)</span></a></span><div id="menus"></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">内存带宽(resctrl)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-categories"><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/linux/">linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><p>以下是<code>Documentation/x86/resctrl.rst</code>翻译：</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>英特尔将此功能称为”英特尔资源导向技术(<code>Resource Director Technology</code>)、(<code>Intel(R) RDT</code>)”。AMD将此功能称为<code>AMD QoS</code>。</p>
<p>此功能由<code>CONFIG_X86_CPU_RESCTRL</code>和<code>x86</code>的<code>/proc/cpuinfo</code>标志位启用。<br>标志位：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>RDT</td>
<td>(Resource Director Technology) Allocation</td>
<td>“rdt_a”</td>
</tr>
<tr>
<td>CAT</td>
<td>(Cache Allocation Technology)</td>
<td>“cat_l3”, “cat_l2”</td>
</tr>
<tr>
<td>CDP</td>
<td>(Code and Data Prioritization)</td>
<td>“cdp_l3”, “cdp_l2”</td>
</tr>
<tr>
<td>CQM</td>
<td>(Cache QoS Monitoring)</td>
<td>“cqm_llc”, “cqm_occup_llc”</td>
</tr>
<tr>
<td>MBM</td>
<td>(Memory Bandwidth Monitoring)</td>
<td>“cqm_mbm_total”, “cqm_mbm_local”</td>
</tr>
<tr>
<td>MBA</td>
<td>(Memory Bandwidth Allocation)</td>
<td>“mba”</td>
</tr>
<tr>
<td>SMBA</td>
<td>(Slow Memory Bandwidth Allocation)</td>
<td></td>
</tr>
<tr>
<td>BMEC</td>
<td>(Bandwidth Monitoring Event Configuration)</td>
<td></td>
</tr>
</tbody></table>
<p>要使用该功能，请挂载文件系统：</p>
<p><code># mount -t resctrl resctrl [-o cdp[,cdpl2][,mba_MBps]] /sys/fs/resctrl</code></p>
<p>挂载选项包括如下几种：</p>
<ul>
<li>“cdp”: 启用<code>L3</code>缓存分配中的代码&#x2F;数据优先级。</li>
<li>“cdpl2”: 启用<code>L2</code>缓存分配中的代码&#x2F;数据优先级。</li>
<li>“mba_MBps”: 启用 MBA 软件控制器(mba_sc)以 MBps 指定 MBA 带宽。</li>
</ul>
<p><code>L2</code>&#x2F;<code>L3</code>&#x2F;<code>CDP</code>&#x2F;是独立控制的。</p>
<p><code>RDT</code>功能是正交的。特定的系统可能只支持监控或只支持控制，或者两者都支持。<br><code>缓存伪锁定 (Cache pseudo-locking)</code>是一种独特的使用缓存控制来<code>pin</code>或<code>lock</code>缓存中数据的方法”。<br>详细信息可以在<code>Cache Pseudo-Locking</code>部分找到。</p>
<p>如果分配或监控功能中的任何一个存在，挂载就会成功，但只会创建系统支持的文件和目录。有关监控和分配期间接口行为的更多详细信息，请参阅“资源分配和监控组”部分。</p>
<h2 id="info目录"><a href="#info目录" class="headerlink" title="info目录"></a>info目录</h2><p><code>info</code>目录包含有关已启用资源的信息。每个资源都有自己的子目录。子目录名称反映了资源名称。</p>
<p>每个子目录都包含以下与分配相关的文件：</p>
<h3 id="Cache-resource子目录"><a href="#Cache-resource子目录" class="headerlink" title="Cache resource子目录"></a>Cache resource子目录</h3><p>Cache resource子目录包含如下与分配相关的文件：</p>
<ul>
<li>“num_closids”: 对于此资源有效的 CLOSID 数量。内核使用所有已启用资源中最小的 CLOSID 数量作为限制。</li>
<li>“”cbm_mask”: 对于此资源有效的位掩码。此掩码相当于 100%。</li>
<li>“”min_cbm_bits”: 写入掩码时必须设置的最小连续位数。</li>
<li>“”shareable_bits”:与其它执行实体（例如 I&#x2F;O）共享资源的位掩码。用户在设置独占缓存分区时可以使用此项。请注意，某些平台支持具有自己缓存使用设置的设备，这些设置可以覆盖这些位。</li>
<li>“”bit_usage”: 显示资源所有实例使用情况的带注释的容量位掩码。图例为：<ul>
<li>“”0”: 相应区域未使用。当系统资源已分配并在 “bit_usage” 中发现 “0” 时，这表明资源被浪费了。</li>
<li>“”H”: 相应区域仅供硬件使用，但可供软件使用。如果一个资源在 “shareable_bits” 中设置了位，但并非所有这些位都出现在资源组的 schematas 中，那么出现在 “shareable_bits” 中但未出现在任何资源组中的位将被标记为 “H”。</li>
<li>“”X”: 相应区域可供共享，并由硬件和软件使用。这些位出现在 “shareable_bits” 以及资源组的分配中。</li>
<li>“”S”: 相应区域由软件使用、且可供共享。</li>
<li>“E”: 相应区域由一个资源组独占使用。不允许共享。</li>
<li>“P”: 相应区域被伪锁定。不允许共享。</li>
</ul>
</li>
</ul>
<h3 id="Memory-bandwidth-MB-子目录"><a href="#Memory-bandwidth-MB-子目录" class="headerlink" title="Memory bandwidth(MB)子目录"></a>Memory bandwidth(MB)子目录</h3><p>Memory bandwidth(MB)子目录包含以下与分配相关的文件：</p>
<ul>
<li><p>“min_bandwidth”: 用户可以请求的最小内存带宽百分比。</p>
</li>
<li><p>“bandwidth_gran”: 内存带宽百分比分配的粒度。分配的带宽百分比将被四舍五入到硬件上可用的下一个控制步长。可用的带宽控制步长为：min_bandwidth + N * bandwidth_gran。</p>
</li>
<li><p>“delay_linear”: 指示延迟比例是线性的还是非线性的。此字段仅用于信息目的。</p>
</li>
<li><p>“thread_throttle_mode”: 在英特尔系统上，指示物理核心上的线程在请求不同内存带宽百分比时如何被限制：</p>
</li>
<li><p>“max”: 最小百分比应用于所有线程。</p>
</li>
<li><p>“per-thread”: 带宽百分比直接应用于核心上运行的线程。</p>
</li>
</ul>
<p>如果 RDT 监控可用，将有一个 “L3_MON” 目录，其中包含以下文件：</p>
<ul>
<li><p>“num_rmids”: 可用的 RMID 数量。这是可以创建多少个 “CTRL_MON” + “MON” 组的上限。</p>
</li>
<li><p>“mon_features”: 如果为资源启用了监控，则列出监控事件。<br>  示例：<br>  <code># cat /sys/fs/resctrl/info/L3_MON/mon_features</code><br>  llc_occupancy<br>  mbm_total_bytes<br>  mbm_local_bytes<br>  如果系统支持带宽监控事件配置 (BMEC)，则带宽事件将是可配置的。输出将是：<br>  <code># cat /sys/fs/resctrl/info/L3_MON/mon_features</code><br>  llc_occupancy<br>  mbm_total_bytes<br>  mbm_total_bytes_config<br>  mbm_local_bytes<br>  mbm_local_bytes_config</p>
</li>
<li><p>“mbm_total_bytes_config”, “mbm_local_bytes_config”:<br>  读&#x2F;写文件，分别包含 mbm_total_bytes 和 mbm_local_bytes 事件的配置，当支持带宽监控事件配置 (BMEC) 功能时。事件配置设置是域特定的，并影响域中的所有 CPU。当任何事件配置发生更改时，该域中两个事件（mbm_total_bytes 和 mbm_local_bytes）的所有 RMID 的带宽计数器都将被清除。每次读取的下一个 RMID 将报告“Unavailable”，随后的读取将报告有效值。<br>  支持的事件类型如下：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>6</td>
<td>从 QoS 域到所有内存类型的脏受害者</td>
</tr>
<tr>
<td>5</td>
<td>取非本地 NUMA 域中的慢速内存</td>
</tr>
<tr>
<td>4</td>
<td>读取本地 NUMA 域中的慢速内存</td>
</tr>
<tr>
<td>3</td>
<td>非本地 NUMA 域的非临时写入</td>
</tr>
<tr>
<td>2</td>
<td>本地 NUMA 域的非临时写入</td>
</tr>
<tr>
<td>1</td>
<td>读取非本地 NUMA 域中的内存</td>
</tr>
<tr>
<td>0</td>
<td>读取本地 NUMA 域中的内存</td>
</tr>
</tbody></table>
<p>  默认情况下，mbm_total_bytes 配置设置为 0x7f 以计数所有事件类型，mbm_local_bytes 配置设置为 0x15 以计数所有本地内存事件。<br>  示例：</p>
<ul>
<li><p>查看当前配置：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># cat /sys/fs/resctrl/info/L3_MON/mbm_total_bytes_config</span></span><br><span class="line"><span class="number">0</span>=<span class="number">0x7f</span>;<span class="number">1</span>=<span class="number">0x7f</span>;<span class="number">2</span>=<span class="number">0x7f</span>;<span class="number">3</span>=<span class="number">0x7f</span></span><br><span class="line"><span class="meta"># cat /sys/fs/resctrl/info/L3_MON/mbm_local_bytes_config</span></span><br><span class="line"><span class="number">0</span>=<span class="number">0x15</span>;<span class="number">1</span>=<span class="number">0x15</span>;<span class="number">3</span>=<span class="number">0x15</span>;<span class="number">4</span>=<span class="number">0x15</span></span><br></pre></td></tr></table></figure></li>
<li><p>要将 mbm_total_bytes 更改为只计数域 0 上的读取，需要设置位 0, 1, 4 和 5，即二进制 110011b（十六进制 0x33）：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># echo <span class="string">&quot;0=0x33&quot;</span> &gt; /sys/fs/resctrl/info/L3_MON/mbm_total_bytes_config</span></span><br><span class="line"><span class="meta"># cat /sys/fs/resctrl/info/L3_MON/mbm_total_bytes_config</span></span><br><span class="line"><span class="number">0</span>=<span class="number">0x33</span>;<span class="number">1</span>=<span class="number">0x7f</span>;<span class="number">2</span>=<span class="number">0x7f</span>;<span class="number">3</span>=<span class="number">0x7f</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>要将 mbm_local_bytes 更改为计数域 0 和 1 上的所有慢速内存读取，需要设置位 4 和 5，即二进制 110000b（十六进制 0x30）：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># echo <span class="string">&quot;0=0x30;1=0x30&quot;</span> &gt; /sys/fs/resctrl/info/L3_MON/mbm_local_bytes_config</span></span><br><span class="line"><span class="meta"># cat /sys/fs/resctrl/info/L3_MON/mbm_local_bytes_config</span></span><br><span class="line"><span class="number">0</span>=<span class="number">0x30</span>;<span class="number">1</span>=<span class="number">0x30</span>;<span class="number">3</span>=<span class="number">0x15</span>;<span class="number">4</span>=<span class="number">0x15</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>“max_threshold_occupancy”:<br>  读&#x2F;写文件，提供一个最大的值（以字节为单位），在该值下，先前使用的 LLC_occupancy 计数器可以被视为可重复使用。</p>
</li>
</ul>
<p>最后，在 “info” 目录的顶层有一个名为 “last_cmd_status” 的文件。此文件会在每次通过文件系统发出“命令”时重置（创建新目录或写入任何控制文件）。如果命令成功，它将显示为“ok”。如果命令失败，它将提供文件操作错误返回中无法传达的更多信息。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># echo L3:0=f7 &gt; schemata</span></span><br><span class="line">bash: echo: write error: Invalid argument</span><br><span class="line"><span class="meta"># cat info/last_cmd_status</span></span><br><span class="line">mask f7 has non-consecutive <span class="number">1</span>-bits</span><br></pre></td></tr></table></figure>

<h2 id="资源分配和监控组"><a href="#资源分配和监控组" class="headerlink" title="资源分配和监控组"></a>资源分配和监控组</h2><p>资源组(Resource Group)在<code>resctrl</code>文件系统中以目录形式表示。默认组是根目录，挂载后，它立即拥有系统中所有任务和 CPU，并可以充分利用所有资源。<br>在具有 RDT 控制功能的系统上，可以在根目录中创建额外的目录，以指定每种资源的不同数量（见下文“schemata”）。根目录和这些额外的顶级目录在下文中称为 “CTRL_MON” 组。<br>在具有 RDT 监控功能的系统上，根目录和其他顶级目录包含一个名为 “mon_groups” 的目录，可以在其中创建额外的目录，以监控其祖先 CTRL_MON 组中的任务子集。在本文档的其余部分中，这些称为 “MON” 组。<br>删除目录将把该组拥有的所有任务和 CPU 移动到父级。删除一个已创建的 CTRL_MON 组将自动删除其下方的所有 MON 组。<br>所有组都包含以下文件：</p>
<ul>
<li>“tasks”: 读取此文件会显示属于此组的所有任务列表。向文件写入任务 ID 会将任务添加到该组。如果该组是<code>CTRL_MON</code>组，则该任务将从之前拥有该任务的任何<code>CTRL_MON</code>组以及拥有该任务的任何 MON 组中移除。如果该组是 MON 组，则该任务必须已属于该组的 CTRL_MON 父级。该任务将从任何先前的 MON 组中移除。</li>
<li>“cpus”: 读取此文件会显示该组拥有的逻辑 CPU 的位掩码。向此文件写入掩码会向该组添加和移除 CPU。与 tasks 文件一样，维护着一个层次结构，其中 MON 组只能包含其父 CTRL_MON 组拥有的 CPU。当资源组处于伪锁定模式时，此文件将只可读，反映与伪锁定区域关联的 CPU。</li>
<li>“cpus_list”: 与 “cpus” 类似，只是使用 CPU 范围而不是位掩码。</li>
</ul>
<p>当启用控制时，所有 CTRL_MON 组也将包含：</p>
<ul>
<li><p>“schemata”: 此组可用的所有资源列表。每个资源都有自己的行和格式 - 详情见下文。</p>
</li>
<li><p>“size”: 镜像 “schemata” 文件的显示，以字节为单位显示每个分配的大小，而不是表示分配的位数。</p>
</li>
<li><p>“mode”: 资源组的“模式”决定了其分配的共享方式。“shareable”资源组允许共享其分配，而“exclusive”资源组不允许共享。通过首先将“pseudo-locksetup”写入“mode”文件，然后将缓存伪锁定区域的 schemata 写入资源组的“schemata”文件，来创建缓存伪锁定区域 [22, 23]。成功创建伪锁定区域后，模式将自动更改为“pseudo-locked”。</p>
</li>
</ul>
<p>当启用监控时，所有 MON 组也将包含：</p>
<ul>
<li>“mon_data”:这包含一组按 L3 域和 RDT 事件组织的文件。例如，在具有两个L3域的系统上，将有子目录 “mon_L3_00” 和 “mon_L3_01” 。这些目录中的每一个都包含每个事件的一个文件（例如 “llc_occupancy”, “mbm_total_bytes”, 和 “mbm_local_bytes”）。在 MON 组中，这些文件提供组中所有任务的事件当前值的读取。在 CTRL_MON 组中，这些文件提供 CTRL_MON 组中所有任务以及 MON 组中所有任务的总和。有关用法的更多详细信息，请参阅示例部分。</li>
</ul>
<h2 id="Resource-Allocation-rules-资源分配规则"><a href="#Resource-Allocation-rules-资源分配规则" class="headerlink" title="Resource Allocation rules(资源分配规则)"></a>Resource Allocation rules(资源分配规则)</h2><p>当任务运行时，以下规则定义了它可用的资源：</p>
<ol>
<li>如果任务是某个非默认组的成员，则使用该组的 schemata。</li>
<li>否则，如果任务属于默认组，但正在分配给特定组的 CPU 上运行，则使用该 CPU 组的 schemata。</li>
<li>否则，使用默认组的 schemata。</li>
</ol>
<p>资源监控规则：</p>
<ol>
<li>如果任务是 MON 组或非默认 CTRL_MON 组的成员，则该任务的 RDT 事件将报告在该组中。</li>
<li>如果任务是默认 CTRL_MON 组的成员，但正在分配给特定组的 CPU 上运行，则该任务的 RDT 事件将报告在该组中。</li>
<li>否则，该任务的 RDT 事件将报告在根级别的 “mon_data” 组中。</li>
</ol>
<p>关于缓存占用监控和控制的注意事项：<br>当将任务从一个组移动到另一个组时，您应该记住，这只影响任务的 新缓存分配。例如，您可能在一个监控组中有一个任务显示 3 MB 的缓存占用。如果您移动到一个新组并立即检查旧组和新组的占用情况，您可能会发现旧组仍然显示 3 MB，而新组显示零。当任务访问移动前仍在缓存中的位置时，硬件不会更新任何计数器。在繁忙的系统上，您可能会看到旧组中的占用随着缓存行的逐出和重用而下降，而新组中的占用随着任务访问内存和加载到缓存中的数据根据新组的成员资格进行计数而上升。<br>这同样适用于缓存分配控制。将任务移动到具有较小缓存分区的组不会逐出任何缓存行。<br>该进程可能会继续使用旧分区中的缓存行。<br>硬件使用 CLOSid（服务类别 ID）和 RMID（资源监控 ID）分别标识控制组和监控组。每个资源组都根据其类型映射到这些 ID。CLOSid 和 RMID 的数量受硬件限制，因此如果CLOSID 或 RMID 耗尽，创建 “CTRL_MON” 目录可能会失败，如果 RMID 耗尽，创建 “MON” 组可能会失败。</p>
<ul>
<li><p>max_threshold_occupancy - 通用概念：请注意，一个被释放的 RMID 可能不会立即被使用，因为该 RMID 仍然被前一个使用者的缓存行标记。因此，此类 RMID 被放置在“待处理列表 (limbo list)”中，并在缓存占用率下降时进行检查。如果系统中有大量待处理 RMID 但尚未准备好使用，用户可能会在 <code>mkdir</code> 期间看到 -EBUSY。max_threshold_occupancy 是一个用户可配置的值，用于确定 RMID 何时可以被释放的占用阈值。</p>
</li>
<li><p>Schemata 文件 - 通用概念：文件中的每一行描述一个资源。该行以资源名称开头，后跟应用于系统上该资源每个实例的特定值。</p>
</li>
<li><p>缓存 ID：在当前一代系统中，每个插槽有一个L3缓存，L2缓存通常只由核心上的超线程共享，但这不是架构要求。我们可以在一个插槽上拥有多个独立的L3缓存，多个核心可以共享一个 L2 缓存。因此，我们不使用“插槽”或“核心”来定义共享资源的逻辑 CPU 集，而是使用“缓存 ID” 。在给定的缓存级别上，这将在整个系统中是一个唯一的数字（但不能保证是连续序列，可能存在间隙）。要查找每个逻辑 CPU 的 ID，请查看 &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu*&#x2F;cache&#x2F;index*&#x2F;id。</p>
</li>
<li><p>缓存位掩码 (CBM)：对于缓存资源，我们使用位掩码来描述可用于分配的缓存部分。掩码的最大值由每个 CPU 模型定义（并且可能对不同的缓存级别不同）。它通过 CPUID 找到，但在 resctrl 文件系统的 “info” 目录中的 “info&#x2F;{resource}&#x2F;cbm_mask” 也提供。英特尔硬件要求这些掩码中的所有“1”位都位于一个连续块中。因此，0x3、0x6 和 0xC 是合法的 4 位掩码，设置了两位，但 0x5、0x9 和 0xA 则不是。在一个具有 20 位掩码的系统上，每个位代表缓存容量的 5%。您可以将缓存划分为四个相等的部分，使用掩码：0x1f、0x3e0、0x7c00、0xf8000。</p>
</li>
</ul>
<h2 id="内存带宽分配和监控"><a href="#内存带宽分配和监控" class="headerlink" title="内存带宽分配和监控"></a>内存带宽分配和监控</h2><p>对于内存带宽资源，默认情况下，用户通过指示总内存带宽的百分比来控制资源。<br>每个 CPU 型号的最小带宽百分比值是预定义的，可以通过 “info&#x2F;MB&#x2F;min_bandwidth” 查找。分配的带宽粒度也取决于 CPU 型号，可以在 “info&#x2F;MB&#x2F;bandwidth_gran” 查找。可用的带宽控制步长为：min_bw + N * bw_gran。中间值四舍五入到硬件上可用的下一个控制步长。</p>
<p>在某些英特尔 SKU 上，带宽限制是核心特定的机制。在共享一个核心的两个线程上使用高带宽和低带宽设置，可能会导致两个线程都被限制使用低带宽（参见 “thread_throttle_mode”）。</p>
<p>内存带宽分配 (MBA) 可能是核心特定机制，而内存带宽监控 (MBM) 是在封装级别完成的，这可能会在使用 MBA 进行控制，然后监控带宽以查看控制是否有效时导致混淆。以下是此类场景：</p>
<ol>
<li><p>用户可能看不到实际带宽在百分比值增加时增加：这种情况可能发生在聚合 L2 外部带宽大于 L3 外部带宽时。考虑一个具有 24 个核心的 SKL SKU，其中 L2 外部带宽为 10GBps（因此聚合 L2 外部带宽为 240GBps），L3 外部带宽为 100GBps。现在，一个工作负载有“20 个线程，每个消耗 5GBps，带宽为 50%”，它消耗了最大的 L3带宽 100GBps，尽管指定的百分比值仅为 50% &lt;&lt; 100%。因此，增加带宽百分比将不会产生更多的带宽。这是因为虽然 L2 外部带宽仍有容量，但 L3 外部带宽已完全使用。另请注意，这取决于基准测试运行的核心数量。</p>
</li>
<li><p>相同的带宽百分比可能意味着不同的实际带宽，取决于线程数量：对于 #1 中的相同 SKU，“单线程，10% 带宽”和“4 线程，10% 带宽”可以分别消耗高达 10GBps 和 40GBps，尽管它们具有相同的 10% 百分比带宽。这仅仅是因为随着线程开始在 rdtgroup 中使用更多核心，实际带宽可能会增加或变化，尽管用户指定的带宽百分比相同。</p>
</li>
</ol>
<p>为了缓解这个问题并使接口更用户友好，resctrl 添加了以 MBps 指定带宽的支持。内核在底层将使用软件反馈机制或“软件控制器(mba_sc)”，它使用 MBM 计数器读取实际带宽并调整内存带宽百分比以确保：<br>“实际带宽 &lt; 用户指定的带宽”。</p>
<p>默认情况下，schemata 将采用带宽百分比值，而用户可以使用挂载选项 ‘mba_MBps’ 切换到“MBA 软件控制器”模式。schemata 格式在以下部分中指定。</p>
<h3 id="L3-schemata-文件详细信息（代码和数据优先级禁用）："><a href="#L3-schemata-文件详细信息（代码和数据优先级禁用）：" class="headerlink" title="L3 schemata 文件详细信息（代码和数据优先级禁用）："></a>L3 schemata 文件详细信息（代码和数据优先级禁用）：</h3><p>禁用 CDP 时，L3 schemata 格式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L3:=;=;...</span><br></pre></td></tr></table></figure>

<h3 id="L3-schemata-文件详细信息（通过挂载选项启用-CDP-到-resctrl）"><a href="#L3-schemata-文件详细信息（通过挂载选项启用-CDP-到-resctrl）" class="headerlink" title="L3 schemata 文件详细信息（通过挂载选项启用 CDP 到 resctrl）"></a>L3 schemata 文件详细信息（通过挂载选项启用 CDP 到 resctrl）</h3><p>当 CDP 启用时，L3 控制分为两个独立的资源，因此您可以为代码和数据指定独立的掩码，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L3DATA:=;=;...</span><br><span class="line">L3CODE:=;=;...</span><br></pre></td></tr></table></figure>

<h3 id="L2-schemata-文件详细信息"><a href="#L2-schemata-文件详细信息" class="headerlink" title="L2 schemata 文件详细信息"></a>L2 schemata 文件详细信息</h3><p>L2 支持 CDP，使用 ‘cdpl2’ 挂载选项。schemata 格式可以是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L2:=;=;...</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L2DATA:=;=;...</span><br><span class="line">L2CODE:=;=;...</span><br></pre></td></tr></table></figure>

<h3 id="内存带宽分配（默认模式）"><a href="#内存带宽分配（默认模式）" class="headerlink" title="内存带宽分配（默认模式）"></a>内存带宽分配（默认模式）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内存带宽域是 L3 缓存。</span><br><span class="line">MB:=bandwidth0;=bandwidth1;...</span><br></pre></td></tr></table></figure>

<h3 id="内存带宽分配以-MBps-指定"><a href="#内存带宽分配以-MBps-指定" class="headerlink" title="内存带宽分配以 MBps 指定"></a>内存带宽分配以 MBps 指定</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内存带宽域是 L3 缓存。</span><br><span class="line">MB:=bw_MBps0;=bw_MBps1;...</span><br></pre></td></tr></table></figure>

<h3 id="慢速内存带宽分配-SMBA"><a href="#慢速内存带宽分配-SMBA" class="headerlink" title="慢速内存带宽分配 (SMBA)"></a>慢速内存带宽分配 (SMBA)</h3><p>AMD 硬件支持慢速内存带宽分配 (SMBA)。CXL.memory 是唯一支持的“慢速”内存设备。通过 SMBA 的支持，硬件可以在慢速内存设备上启用带宽分配。如果系统中存在多个此类设备，节流逻辑会将所有慢速源分组在一起，并对它们整体应用限制。</p>
<p>SMBA（与 CXL.memory）的存在与慢速内存设备的存在无关。如果系统上没有此类设备，则配置 SMBA 将对系统性能没有影响。</p>
<p>慢速内存的带宽域是 L3 缓存。其 schemata 文件<br>格式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMBA:=bandwidth0;=bandwidth1;...</span><br></pre></td></tr></table></figure>

<h3 id="读取-写入-schemata-文件"><a href="#读取-写入-schemata-文件" class="headerlink" title="读取&#x2F;写入 schemata 文件"></a>读取&#x2F;写入 schemata 文件</h3><p>读取 schemata 文件将显示所有域上所有资源的状态。写入时，您只需指定要更改的值。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># cat schemata</span></span><br><span class="line">L3DATA:<span class="number">0</span>=fffff;<span class="number">1</span>=fffff;<span class="number">2</span>=fffff;<span class="number">3</span>=fffff</span><br><span class="line">L3CODE:<span class="number">0</span>=fffff;<span class="number">1</span>=fffff;<span class="number">2</span>=fffff;<span class="number">3</span>=fffff</span><br><span class="line"><span class="meta"># echo <span class="string">&quot;L3DATA:2=3c0;&quot;</span> &gt; schemata</span></span><br><span class="line"><span class="meta"># cat schemata</span></span><br><span class="line">L3DATA:<span class="number">0</span>=fffff;<span class="number">1</span>=fffff;<span class="number">2</span>=<span class="number">3</span>c0;<span class="number">3</span>=fffff</span><br><span class="line">L3CODE:<span class="number">0</span>=fffff;<span class="number">1</span>=fffff;<span class="number">2</span>=fffff;<span class="number">3</span>=fffff</span><br></pre></td></tr></table></figure>

<h3 id="读取-写入-schemata-文件（在-AMD-系统上）"><a href="#读取-写入-schemata-文件（在-AMD-系统上）" class="headerlink" title="读取&#x2F;写入 schemata 文件（在 AMD 系统上）"></a>读取&#x2F;写入 schemata 文件（在 AMD 系统上）</h3><p>读取 schemata 文件将显示所有域的当前带宽限制。分配的资源以八分之一 GB&#x2F;s 的倍数表示。写入文件时，您需要指定要配置带宽限制的缓存 ID。</p>
<p>例如，要在第一个缓存 ID 上分配 2GB&#x2F;s 的限制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># cat schemata</span></span><br><span class="line">MB:<span class="number">0</span>=<span class="number">2048</span>;<span class="number">1</span>=<span class="number">2048</span>;<span class="number">2</span>=<span class="number">2048</span>;<span class="number">3</span>=<span class="number">2048</span></span><br><span class="line">L3:<span class="number">0</span>=ffff;<span class="number">1</span>=ffff;<span class="number">2</span>=ffff;<span class="number">3</span>=ffff</span><br><span class="line"><span class="meta"># echo <span class="string">&quot;MB:1=16&quot;</span> &gt; schemata</span></span><br><span class="line"><span class="meta"># cat schemata</span></span><br><span class="line">MB:<span class="number">0</span>=<span class="number">2048</span>;<span class="number">1</span>= <span class="number">16</span>;<span class="number">2</span>=<span class="number">2048</span>;<span class="number">3</span>=<span class="number">2048</span></span><br><span class="line">L3:<span class="number">0</span>=ffff;<span class="number">1</span>=ffff;<span class="number">2</span>=ffff;<span class="number">3</span>=ffff</span><br></pre></td></tr></table></figure>

<h3 id="读取-写入-schemata-文件（在-AMD-系统上）与-SMBA-功能"><a href="#读取-写入-schemata-文件（在-AMD-系统上）与-SMBA-功能" class="headerlink" title="读取&#x2F;写入 schemata 文件（在 AMD 系统上）与 SMBA 功能"></a>读取&#x2F;写入 schemata 文件（在 AMD 系统上）与 SMBA 功能</h3><p>读取和写入 schemata 文件与上面没有 SMBA 的情况相同。</p>
<p>例如，要在第一个缓存 ID 上分配 8GB&#x2F;s 的限制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># cat schemata</span></span><br><span class="line">SMBA:<span class="number">0</span>=<span class="number">2048</span>;<span class="number">1</span>=<span class="number">2048</span>;<span class="number">2</span>=<span class="number">2048</span>;<span class="number">3</span>=<span class="number">2048</span></span><br><span class="line">MB:<span class="number">0</span>=<span class="number">2048</span>;<span class="number">1</span>=<span class="number">2048</span>;<span class="number">2</span>=<span class="number">2048</span>;<span class="number">3</span>=<span class="number">2048</span></span><br><span class="line">L3:<span class="number">0</span>=ffff;<span class="number">1</span>=ffff;<span class="number">2</span>=ffff;<span class="number">3</span>=ffff</span><br><span class="line"><span class="meta"># echo <span class="string">&quot;SMBA:1=64&quot;</span> &gt; schemata</span></span><br><span class="line"><span class="meta"># cat schemata</span></span><br><span class="line">SMBA:<span class="number">0</span>=<span class="number">2048</span>;<span class="number">1</span>= <span class="number">64</span>;<span class="number">2</span>=<span class="number">2048</span>;<span class="number">3</span>=<span class="number">2048</span></span><br><span class="line">MB:<span class="number">0</span>=<span class="number">2048</span>;<span class="number">1</span>=<span class="number">2048</span>;<span class="number">2</span>=<span class="number">2048</span>;<span class="number">3</span>=<span class="number">2048</span></span><br><span class="line">L3:<span class="number">0</span>=ffff;<span class="number">1</span>=ffff;<span class="number">2</span>=ffff;<span class="number">3</span>=ffff</span><br></pre></td></tr></table></figure>

<h2 id="缓存伪锁定"><a href="#缓存伪锁定" class="headerlink" title="缓存伪锁定"></a>缓存伪锁定</h2><p>CAT 允许用户指定应用程序可以填充的缓存空间量。缓存伪锁定基于 CPU 仍然可以读取和写入当前分配区域之外的预分配数据（在缓存命中时）的事实。通过缓存伪锁定，数据可以预加载到缓存的保留部分，没有任何应用程序可以填充，并且从那时起只服务于缓存命中 [45, 46]。伪锁定的内存被暴露给用户空间，应用程序可以将其映射到其虚拟地址空间，从而拥有一个平均读取延迟降低的内存区域。</p>
<p>缓存伪锁定区域的创建由用户请求触发，并附带要伪锁定区域的 schemata。缓存伪锁定区域的创建如下：</p>
<ul>
<li>创建一个 CAT 分配 CLOSNEW，其 CBM 与用户请求伪锁定缓存区域的 schemata 匹配 [46, 47]。该区域不得与系统上任何当前 CAT 分配&#x2F;CLOS 重叠，并且在该伪锁定区域存在期间，不允许未来与该缓存区域重叠。</li>
<li>创建一个与缓存区域大小相同的连续内存区域。</li>
<li>刷新缓存，禁用硬件预取器，禁用抢占。</li>
<li>将 CLOSNEW 设置为活动 CLOS，并触摸分配的内存以将其加载到缓存中。</li>
<li>设置先前的 CLOS 为活动状态。</li>
<li>此时可以释放 closid CLOSNEW - 只要其 CBM 未出现在任何 CAT 分配中，缓存伪锁定区域就会受到保护。尽管缓存伪锁定区域从此以后不会出现在任何 CLOS 的任何 CBM 中，但运行任何 CLOS 的应用程序都能够访问伪锁定区域中的内存，因为该区域继续服务于缓存命中。</li>
<li>加载到缓存中的连续内存区域作为字符设备暴露给用户空间。</li>
</ul>
<p>缓存伪锁定通过仔细配置 CAT 功能和控制应用程序行为来增加数据留在缓存中的概率。无法保证数据被放置在缓存中。INVD、WBINVD、CLFLUSH 等指令仍然可以将“锁定”数据从缓存中逐出。电源管理 C-状态可能会缩小或关闭缓存。在创建伪锁定区域时，更深的 C-状态将自动受到限制。</p>
<p>使用伪锁定区域的应用程序必须将其亲和性绑定到与伪锁定区域所在的缓存关联的核心（或核心子集）[49, 50]。代码中的健全性检查将不允许应用程序映射伪锁定内存，除非它运行的亲和性绑定到与伪锁定区域所在的缓存关联的核心。健全性检查仅在初始 mmap() 处理期间执行，之后没有强制执行，应用程序本身需要确保其保持与正确核心的亲和性。</p>
<p>伪锁定分两个阶段完成：</p>
<ol>
<li>在第一阶段，系统管理员分配一部分缓存，专门用于伪锁定。此时，分配相应部分的内存，加载到分配的缓存部分中，并作为字符设备暴露。</li>
<li>在第二阶段，用户空间应用程序将伪锁定内存映射(mmap())到其地址空间。</li>
</ol>
<h3 id="缓存伪锁定接口"><a href="#缓存伪锁定接口" class="headerlink" title="缓存伪锁定接口"></a>缓存伪锁定接口</h3><p>伪锁定区域的创建使用 resctrl 接口，如下所示：</p>
<ol>
<li>通过在 &#x2F;sys&#x2F;fs&#x2F;resctrl 中创建一个新目录来创建新的资源组。</li>
<li>通过将“pseudo-locksetup”写入“mode”文件，将新资源组的模式更改为“pseudo-locksetup”。</li>
<li>将伪锁定区域的 schemata 写入“schemata”文件。schemata 中的所有位应根据“bit_usage”文件是“未使用”的。</li>
</ol>
<p>成功创建伪锁定区域后，“mode”文件将包含“pseudo-locked”，并且在 &#x2F;dev&#x2F;pseudo_lock 中将存在一个与资源组同名的新字符设备。此字符设备可以由用户空间进行 mmap() 以获取对伪锁定内存区域的访问 [52, 53]。</p>
<p>缓存伪锁定区域创建和使用的示例可以在下面找到。</p>
<h3 id="缓存伪锁定调试接口"><a href="#缓存伪锁定调试接口" class="headerlink" title="缓存伪锁定调试接口"></a>缓存伪锁定调试接口</h3><p>伪锁定调试接口默认启用（如果启用了 CONFIG_DEBUG_FS），并且可以在 &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;resctrl 中找到。</p>
<p>内核没有明确的方法来测试提供的内存位置是否在缓存中。伪锁定调试接口使用跟踪基础设施提供两种测量伪锁定区域缓存驻留的方法：</p>
<ol>
<li>使用 pseudo_lock_mem_latency 跟踪点测量内存访问延迟。这些测量的数据最好使用 hist 触发器进行可视化（参见下面的示例）。在此测试中，伪锁定区域以 32 字节的步长遍历，同时禁用硬件预取器和抢占。这还提供了缓存命中和未命中的替代可视化。</li>
<li>如果可用，使用模型特定的精确计数器测量缓存命中和未命中。根据系统上的缓存级别，pseudo_lock_l2和 pseudo_lock_l3 跟踪点可用。</li>
</ol>
<p>创建伪锁定区域时，会在 debugfs 中为其创建一个新的 debugfs 目录，路径为<code>/sys/kernel/debug/resctrl/</code>。此目录中存在一个单独的只写文件 pseudo_lock_measure。伪锁定区域的测量取决于写入此 debugfs 文件的数字：</p>
<ol>
<li>将“1”写入 pseudo_lock_measure 文件将触发在 pseudo_lock_mem_latency 跟踪点中捕获的延迟测量 [55, 56]。参见下面的示例。</li>
<li>将“2”写入 pseudo_lock_measure 文件将触发在 pseudo_lock_l2 跟踪点中捕获的 L2 缓存驻留（缓存命中和未命中）测量。参见下面的示例。</li>
<li>将“3”写入 pseudo_lock_measure 文件将触发 L3 缓存驻留（缓存命中和未命中）测量，该测量在 pseudo_lock_l3 跟踪点中捕获。</li>
</ol>
<p>所有测量都通过跟踪基础设施记录。这要求在触发测量之前启用相关的跟踪点。</p>
<h3 id="延迟调试接口示例"><a href="#延迟调试接口示例" class="headerlink" title="延迟调试接口示例"></a>延迟调试接口示例</h3><p>在此示例中，创建了一个名为 “newlock” 的伪锁定区域。以下是如何测量从该区域读取的延迟（以周期为单位）并使用直方图（如果设置了 <code>CONFIG_HIST_TRIGGERS</code>则可用）可视化此数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># :&gt; /sys/kernel/tracing/trace</span><br><span class="line"><span class="meta"># echo <span class="string">&#x27;hist:keys=latency&#x27;</span> &gt; /sys/kernel/tracing/events/resctrl/pseudo_lock_mem_latency/trigger</span></span><br><span class="line"><span class="meta"># echo 1 &gt; /sys/kernel/tracing/events/resctrl/pseudo_lock_mem_latency/enable</span></span><br><span class="line"><span class="meta"># echo 1 &gt; /sys/kernel/debug/resctrl/newlock/pseudo_lock_measure</span></span><br><span class="line"><span class="meta"># echo 0 &gt; /sys/kernel/tracing/events/resctrl/pseudo_lock_mem_latency/enable</span></span><br><span class="line"><span class="meta"># cat /sys/kernel/tracing/events/resctrl/pseudo_lock_mem_latency/hist</span></span><br><span class="line"><span class="meta"># event histogram</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># trigger info: hist:keys=latency:vals=hitcount:sort=hitcount:size=2048 [active]</span></span><br><span class="line">&#123; latency: <span class="number">456</span> &#125; hitcount: <span class="number">1</span></span><br><span class="line">&#123; latency: <span class="number">50</span> &#125; hitcount: <span class="number">83</span></span><br><span class="line">&#123; latency: <span class="number">36</span> &#125; hitcount: <span class="number">96</span></span><br><span class="line">&#123; latency: <span class="number">44</span> &#125; hitcount: <span class="number">174</span></span><br><span class="line">&#123; latency: <span class="number">48</span> &#125; hitcount: <span class="number">195</span></span><br><span class="line">&#123; latency: <span class="number">46</span> &#125; hitcount: <span class="number">262</span></span><br><span class="line">&#123; latency: <span class="number">42</span> &#125; hitcount: <span class="number">693</span></span><br><span class="line">&#123; latency: <span class="number">40</span> &#125; hitcount: <span class="number">3204</span></span><br><span class="line">&#123; latency: <span class="number">38</span> &#125; hitcount: <span class="number">3484</span></span><br></pre></td></tr></table></figure>

<p>总计：<br>命中：8192<br>条目：9<br>丢弃：0</p>
<h3 id="缓存命中-未命中调试示例"><a href="#缓存命中-未命中调试示例" class="headerlink" title="缓存命中&#x2F;未命中调试示例"></a>缓存命中&#x2F;未命中调试示例</h3><p>在此示例中，在平台的 L2 缓存上创建了一个名为 “newlock” 的伪锁定区域 [59]。以下是如何使用平台的精确计数器获取缓存命中和未命中的详细信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># :&gt; /sys/kernel/tracing/trace</span><br><span class="line"><span class="meta"># echo 1 &gt; /sys/kernel/tracing/events/resctrl/pseudo_lock_l2/enable</span></span><br><span class="line"><span class="meta"># echo 2 &gt; /sys/kernel/debug/resctrl/newlock/pseudo_lock_measure</span></span><br><span class="line"><span class="meta"># echo 0 &gt; /sys/kernel/tracing/events/resctrl/pseudo_lock_l2/enable</span></span><br><span class="line"><span class="meta"># cat /sys/kernel/tracing/trace</span></span><br><span class="line"><span class="meta"># tracer: nop</span></span><br><span class="line">#</span><br><span class="line"># _-----=&gt; irqs-off</span><br><span class="line"># / _----=&gt; need-resched</span><br><span class="line"># | / _---=&gt; hardirq/softirq</span><br><span class="line"># || / _--=&gt; preempt-depth</span><br><span class="line"># ||| / delay</span><br><span class="line"># TASK-PID CPU# |||| TIMESTAMP FUNCTION</span><br><span class="line"># | | | |||| | |</span><br><span class="line">pseudo_lock_mea<span class="number">-1672</span> [<span class="number">2</span>] .... <span class="number">3132.860500</span>: pseudo_lock_l2: hits=<span class="number">4097</span> miss=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="RDT-分配用法示例"><a href="#RDT-分配用法示例" class="headerlink" title="RDT 分配用法示例"></a>RDT 分配用法示例</h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><p>在双插槽机器上（每个插槽一个 L3 缓存），只有四个缓存位掩码位，最小带宽为 10%，内存带宽粒度为 10%。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mount -t resctrl resctrl /sys/fs/resctrl</span></span><br><span class="line"><span class="meta"># cd /sys/fs/resctrl</span></span><br><span class="line"><span class="meta"># mkdir p0 p1</span></span><br><span class="line"><span class="meta"># echo <span class="string">&quot;L3:0=3;1=c\nMB:0=50;1=50&quot;</span> &gt; /sys/fs/resctrl/p0/schemata</span></span><br><span class="line"><span class="meta"># echo <span class="string">&quot;L3:0=3;1=3\nMB:0=50;1=50&quot;</span> &gt; /sys/fs/resctrl/p1/schemata</span></span><br></pre></td></tr></table></figure>

<p>默认资源组未修改，因此我们可以访问所有缓存的所有部分（其 schemata 文件读取 “L3:0&#x3D;f;1&#x3D;f”）。<br>受组 “p0” 控制的任务只能从缓存 ID 0 的“下部”50% 和缓存 ID 1 的“上部”50% 进行分配。<br>组 “p1” 中的任务使用两个插槽上缓存的“下部”50%。<br>同样，受组 “p0” 控制的任务在 socket0 和 socket 1 上最多可以使用 50% 的内存带宽。<br>组 “p1” 中的任务也可以在两个插槽上使用 50% 的内存带宽。<br>请注意，与缓存掩码不同，内存带宽不能指定这些分配是否可以重叠。分配指定了组可能能够使用的最大带宽，系统管理员可以相应地配置带宽。<br>如果 resctrl 使用软件控制器 (mba_sc)，则用户可以输入 MB 中的最大带宽，而不是百分比值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># echo <span class="string">&quot;L3:0=3;1=c\nMB:0=1024;1=500&quot;</span> &gt; /sys/fs/resctrl/p0/schemata</span></span><br><span class="line"><span class="meta"># echo <span class="string">&quot;L3:0=3;1=3\nMB:0=1024;1=500&quot;</span> &gt; /sys/fs/resctrl/p1/schemata</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，socket 0 上的 “p1” 和 “p0” 中的任务将使用最大带宽 1024MB，而 socket 1 上它们将使用 500MB。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><p>再次是两个插槽，但这次使用更真实的 20 位掩码。两个实时任务 pid&#x3D;1234 运行在处理器 0 上，pid&#x3D;5678 运行在处理器 1 上，它们位于一个 2 插槽、双核机器的 socket 0 上 [63, 64]。为了避免“嘈杂邻居 (noisy neighbors)”，这两个实时任务各自独占 socket 0 上 L3 缓存的四分之一。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mount -t resctrl resctrl /sys/fs/resctrl</span></span><br><span class="line"><span class="meta"># cd /sys/fs/resctrl</span></span><br></pre></td></tr></table></figure>

<p>首先，我们重置默认组的 schemata，以便 socket 0 的 L3 缓存的“上部”50% 和内存带宽的 50% 不能被普通任务使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># echo <span class="string">&quot;L3:0=3ff;1=fffff\nMB:0=50;1=100&quot;</span> &gt; schemata</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们为第一个实时任务创建一个资源组，并赋予它访问 socket 0 上缓存“顶部”25% 的权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mkdir p0</span></span><br><span class="line"><span class="meta"># echo <span class="string">&quot;L3:0=f8000;1=fffff&quot;</span> &gt; p0/schemata</span></span><br></pre></td></tr></table></figure>

<p>最后，我们将第一个实时任务移入此资源组。我们还使用 taskset(1) 确保任务始终在 socket 0 上的专用 CPU 上运行。大多数资源组的使用也会限制任务在哪些处理器上运行。</p>
<p>对于第二个实时任务（使用剩余的 25% 缓存）也是如此：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mkdir p1</span></span><br><span class="line"><span class="meta"># echo <span class="string">&quot;L3:0=7c00;1=fffff&quot;</span> &gt; p1/schemata</span></span><br><span class="line"><span class="meta"># echo 5678 &gt; p1/tasks</span></span><br><span class="line"><span class="meta"># taskset -cp 2 5678</span></span><br></pre></td></tr></table></figure>

<p>对于具有内存带宽资源和 CAT L3 的相同 2 插槽系统，schemata 将如下所示（假设 min_bandwidth 为 10，bandwidth_gran 为 10）。<br>对于我们的第一个实时任务，这将请求 socket 0 上 20% 的内存带宽。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># echo -e <span class="string">&quot;L3:0=f8000;1=fffff\nMB:0=20;1=100&quot;</span> &gt; p0/schemata</span></span><br></pre></td></tr></table></figure>

<p>对于我们的第二个实时任务，这将请求 socket 0 上另外 20% 的内存带宽。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># echo -e <span class="string">&quot;L3:0=f8000;1=fffff\nMB:0=20;1=100&quot;</span> &gt; p0/schemata</span></span><br></pre></td></tr></table></figure>

<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h4><p>一个单插槽系统，实时任务运行在核心 4-7 上，非实时工作负载分配给核心 0-3。实时任务共享文本和数据，因此不需要每个任务关联，并且由于与内核的交互，希望这些核心上的内核与任务共享 L3。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mount -t resctrl resctrl /sys/fs/resctrl</span></span><br><span class="line"><span class="meta"># cd /sys/fs/resctrl</span></span><br></pre></td></tr></table></figure>

<p>首先，我们重置默认组的 schemata，以便 socket 0 的 L3 缓存的“上部”50% 和 socket 0 的内存带宽的 50% 不能被普通任务使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># echo <span class="string">&quot;L3:0=3ff\nMB:0=50&quot;</span> &gt; schemata</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们为实时核心创建一个资源组，并赋予它访问 socket 0 上缓存“顶部”50% 和 socket 0 上内存带宽 50% 的权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mkdir p0</span></span><br><span class="line"><span class="meta"># echo <span class="string">&quot;L3:0=ffc00\nMB:0=50&quot;</span> &gt; p0/schemata</span></span><br></pre></td></tr></table></figure>

<p>最后，我们将核心 4-7 移到新组，并确保内核和运行在其上的任务获得 50% 的缓存。它们还应该获得 50% 的内存带宽，假设核心 4-7 是 SMT 同级，并且只有实时线程调度在核心 4-7 上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># echo F0 &gt; p0/cpus</span></span><br></pre></td></tr></table></figure>

<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h4><p>前几个示例中的资源组都处于默认的“shareable”模式，允许共享其缓存分配。如果一个资源组配置了一个缓存分配，那么没有什么可以阻止另一个资源组与该分配重叠。<br>在此示例中，将在一个 L2 CAT 系统上创建一个新的独占资源组，该系统具有两个 L2 缓存实例，可以使用 8 位容量位掩码进行配置。新的独占资源组将被配置为使用每个缓存实例的 25%。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mount -t resctrl resctrl /sys/fs/resctrl/</span></span><br><span class="line"><span class="meta"># cd /sys/fs/resctrl</span></span><br></pre></td></tr></table></figure>

<p>首先，我们观察到默认组被配置为分配给所有 L2 缓存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># cat schemata</span></span><br><span class="line">L2:<span class="number">0</span>=ff;<span class="number">1</span>=ff</span><br></pre></td></tr></table></figure>

<p>我们此时可以尝试创建新的资源组，但由于与默认组的 schemata 重叠，它将失败。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mkdir p0</span></span><br><span class="line"><span class="meta"># echo <span class="string">&#x27;L2:0=0x3;1=0x3&#x27;</span> &gt; p0/schemata</span></span><br><span class="line"><span class="meta"># cat p0/mode</span></span><br><span class="line"></span><br><span class="line">shareable</span><br><span class="line"><span class="meta"># echo exclusive &gt; p0/mode</span></span><br><span class="line">-sh: echo: write error: Invalid argument</span><br><span class="line"><span class="meta"># cat info/last_cmd_status</span></span><br><span class="line">schemata overlaps</span><br></pre></td></tr></table></figure>

<p>为了确保不与其他资源组重叠，默认资源组的 schemata 必须改变，从而使新的资源组能够成为独占组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># echo <span class="string">&#x27;L2:0=0xfc;1=0xfc&#x27;</span> &gt; schemata</span></span><br><span class="line"><span class="meta"># echo exclusive &gt; p0/mode</span></span><br><span class="line"><span class="meta"># grep . p0<span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="meta">p0/cpus:0</span></span></span><br><span class="line"><span class="comment"><span class="meta">p0/mode:exclusive</span></span></span><br><span class="line"><span class="comment"><span class="meta">p0/schemata:L2:0=03;1=03</span></span></span><br><span class="line"><span class="comment"><span class="meta">p0/size:L2:0=262144;1=262144</span></span></span><br></pre></td></tr></table></figure>

<p>新资源组在创建时不会与独占资源组重叠。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mkdir p1</span></span><br><span class="line"><span class="meta"># grep . p1<span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="meta">p1/cpus:0</span></span></span><br><span class="line"><span class="comment"><span class="meta">p1/mode:shareable</span></span></span><br><span class="line"><span class="comment"><span class="meta">p1/schemata:L2:0=fc;1=fc</span></span></span><br><span class="line"><span class="comment"><span class="meta">p1/size:L2:0=786432;1=786432</span></span></span><br></pre></td></tr></table></figure>

<p>bit_usage 将反映缓存的使用情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># cat info/L2/bit_usage</span></span><br><span class="line"><span class="number">0</span>=SSSSSSEE;<span class="number">1</span>=SSSSSSEE</span><br></pre></td></tr></table></figure>

<p>资源组不能被强制与独占资源组重叠：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># echo <span class="string">&#x27;L2:0=0x1;1=0x1&#x27;</span> &gt; p1/schemata</span></span><br><span class="line">-sh: echo: write error: Invalid argument</span><br><span class="line"><span class="meta"># cat info/last_cmd_status</span></span><br><span class="line">overlaps with exclusive group</span><br></pre></td></tr></table></figure>

<h2 id="缓存伪锁定示例"><a href="#缓存伪锁定示例" class="headerlink" title="缓存伪锁定示例"></a>缓存伪锁定示例</h2><p>使用 CBM 0x3 锁定缓存 ID 1 的一部分 L2 缓存。伪锁定区域暴露在<code>/dev/pseudo_lock/newlock</code>，可以提供给应用程序作为 mmap() 的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mount -t resctrl resctrl /sys/fs/resctrl/</span></span><br><span class="line"><span class="meta"># cd /sys/fs/resctrl</span></span><br></pre></td></tr></table></figure>

<p>确保有可用于伪锁定的位，因为只有未使用的位可以伪锁定，因此要伪锁定的位需要从默认资源组的 schemata 中移除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># cat info/L2/bit_usage</span></span><br><span class="line"><span class="number">0</span>=SSSSSSSS;<span class="number">1</span>=SSSSSSSS</span><br><span class="line"><span class="meta"># echo <span class="string">&#x27;L2:1=0xfc&#x27;</span> &gt; schemata</span></span><br><span class="line"><span class="meta"># cat info/L2/bit_usage</span></span><br><span class="line"><span class="number">0</span>=SSSSSSSS;<span class="number">1</span>=SSSSSS00</span><br></pre></td></tr></table></figure>

<p>创建一个新的资源组，该组将与伪锁定区域关联，指示它将用于伪锁定区域，并配置请求的伪锁定区域容量位掩码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mkdir newlock</span></span><br><span class="line"><span class="meta"># echo pseudo-locksetup &gt; newlock/mode</span></span><br><span class="line"><span class="meta"># echo <span class="string">&#x27;L2:1=0x3&#x27;</span> &gt; newlock/schemata</span></span><br></pre></td></tr></table></figure>

<p>成功后，资源组的模式将变为 pseudo-locked，bit_usage 将反映伪锁定区域，并且暴露伪锁定区域的字符设备将存在。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cat newlock/mode</span><br><span class="line">pseudo-locked</span><br><span class="line"># cat info/L2/bit_usage</span><br><span class="line">0=SSSSSSSS;1=SSSSSSPP</span><br><span class="line"># ls -l /dev/pseudo_lock/newlock</span><br><span class="line">crw------- 1 root root 243, 0 Apr 3 05:01 /dev/pseudo_lock/newlock</span><br></pre></td></tr></table></figure>

<p>::</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Example code to access one page of pseudo-locked cache region</span></span><br><span class="line"><span class="comment">* from user space.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* It is required that the application runs with affinity to only</span></span><br><span class="line"><span class="comment">* cores associated with the pseudo-locked region. Here the cpu</span></span><br><span class="line"><span class="comment">* is hardcoded for convenience of example.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cpuid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line">  <span class="type">long</span> page_size;</span><br><span class="line">  <span class="type">void</span> *mapping;</span><br><span class="line">  <span class="type">int</span> dev_fd;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">  page_size = sysconf(_SC_PAGESIZE);</span><br><span class="line"></span><br><span class="line">  CPU_ZERO(&amp;cpuset);</span><br><span class="line">  CPU_SET(cpuid, &amp;cpuset);</span><br><span class="line">  ret = sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpuset), &amp;cpuset);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;sched_setaffinity&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dev_fd = open(<span class="string">&quot;/dev/pseudo_lock/newlock&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mapping = mmap(<span class="number">0</span>, page_size, PROT_READ | PROT_WRITE, MAP_SHARED,</span><br><span class="line">          dev_fd, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (mapping == MAP_FAILED) &#123;</span><br><span class="line">    perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    close(dev_fd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Application interacts with pseudo-locked memory @mapping */</span></span><br><span class="line"></span><br><span class="line">  ret = munmap(mapping, page_size);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">    close(dev_fd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  close(dev_fd);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用程序之间的锁定"><a href="#应用程序之间的锁定" class="headerlink" title="应用程序之间的锁定"></a>应用程序之间的锁定</h2><p>resctrl 文件系统上的某些操作，由对多个文件的读&#x2F;写组成，必须是原子的。<br>例如，L3 缓存的独占保留的分配涉及：</p>
<ol>
<li>从每个目录或每个资源的 “bit_usage” 读取 cbmmasks。</li>
<li>在全局 CBM 位掩码中找到一组连续的位，这些位在任何目录 cbmmasks 中都是清除的。</li>
<li>创建一个新目录。</li>
<li>将步骤 2 中找到的位设置为新目录的 “schemata” 文件。</li>
</ol>
<p>如果两个应用程序同时尝试分配空间，它们最终可能会分配相同的位，从而导致保留被共享而不是独占。<br>为了协调 resctrlfs 上的原子操作并避免上述问题，建议采用以下锁定过程：<br>锁定基于 flock，可在 libc 和 shell 脚本命令中使用。</p>
<p>写锁：<br>    A) 对 &#x2F;sys&#x2F;fs&#x2F;resctrl 进行 flock(LOCK_EX)。<br>    B) 读取&#x2F;写入目录结构。<br>    C) funlock。</p>
<p>读锁：<br>    A) 对 &#x2F;sys&#x2F;fs&#x2F;resctrl 进行 flock(LOCK_SH)。<br>    B) 如果成功，读取目录结构。<br>    C) funlock。</p>
<p>Bash 示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原子读取目录结构</span></span><br><span class="line">$ flock -s /sys/fs/resctrl/ find /sys/fs/resctrl</span><br><span class="line"><span class="comment"># 读取目录内容并创建新的子目录</span></span><br><span class="line">$ <span class="built_in">cat</span> create-dir.sh</span><br><span class="line">find /sys/fs/resctrl/ &gt; output.txt</span><br><span class="line">mask = function-of(output.txt)</span><br><span class="line"><span class="built_in">mkdir</span> /sys/fs/resctrl/newres/</span><br><span class="line"><span class="built_in">echo</span> mask &gt; /sys/fs/resctrl/newres/schemata</span><br><span class="line">$ flock /sys/fs/resctrl/ ./create-dir.sh</span><br></pre></td></tr></table></figure>

<p>C 语言示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Example code do take advisory locks</span></span><br><span class="line"><span class="comment">* before accessing resctrl filesystem</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">resctrl_take_shared_lock</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* take shared lock on resctrl filesystem */</span></span><br><span class="line">  ret = flock(fd, LOCK_SH);</span><br><span class="line">  <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    perror(<span class="string">&quot;flock&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">resctrl_take_exclusive_lock</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* release lock on resctrl filesystem */</span></span><br><span class="line">  ret = flock(fd, LOCK_EX);</span><br><span class="line">  <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    perror(<span class="string">&quot;flock&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">resctrl_release_lock</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* take shared lock on resctrl filesystem */</span></span><br><span class="line">  ret = flock(fd, LOCK_UN);</span><br><span class="line">  <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    perror(<span class="string">&quot;flock&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd, ret;</span><br><span class="line"></span><br><span class="line">  fd = open(<span class="string">&quot;/sys/fs/resctrl&quot;</span>, O_DIRECTORY);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  resctrl_take_shared_lock(fd);</span><br><span class="line">  <span class="comment">/* code to read directory contents */</span></span><br><span class="line">  resctrl_release_lock(fd);</span><br><span class="line"></span><br><span class="line">  resctrl_take_exclusive_lock(fd);</span><br><span class="line">  <span class="comment">/* code to read and write directory contents */</span></span><br><span class="line">  resctrl_release_lock(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RDT-监控与分配用法示例"><a href="#RDT-监控与分配用法示例" class="headerlink" title="RDT 监控与分配用法示例"></a>RDT 监控与分配用法示例</h2><h3 id="读取监控数据"><a href="#读取监控数据" class="headerlink" title="读取监控数据"></a>读取监控数据</h3><p>读取事件文件（例如：mon_data&#x2F;mon_L3_00&#x2F;llc_occupancy）将显示相应 MON 组或 CTRL_MON 组的 LLC 占用率的当前快照。</p>
<h4 id="示例-1（监控-CTRL-MON-组和-CTRL-MON-组中的任务子集）"><a href="#示例-1（监控-CTRL-MON-组和-CTRL-MON-组中的任务子集）" class="headerlink" title="示例 1（监控 CTRL_MON 组和 CTRL_MON 组中的任务子集）"></a>示例 1（监控 CTRL_MON 组和 CTRL_MON 组中的任务子集）</h4><p>在双插槽机器上（每个插槽一个 L3 缓存），只有四个缓存位掩码位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mount -t resctrl resctrl /sys/fs/resctrl</span></span><br><span class="line"><span class="meta"># cd /sys/fs/resctrl</span></span><br><span class="line"><span class="meta"># mkdir p0 p1</span></span><br><span class="line"><span class="meta"># echo <span class="string">&quot;L3:0=3;1=c&quot;</span> &gt; /sys/fs/resctrl/p0/schemata</span></span><br><span class="line"><span class="meta"># echo <span class="string">&quot;L3:0=3;1=3&quot;</span> &gt; /sys/fs/resctrl/p1/schemata</span></span><br><span class="line"><span class="meta"># echo 5678 &gt; p1/tasks</span></span><br><span class="line"><span class="meta"># echo 5679 &gt; p1/tasks</span></span><br></pre></td></tr></table></figure>

<p>默认资源组未修改，因此我们可以访问所有缓存的所有部分（其 schemata 文件读取 “L3:0&#x3D;f;1&#x3D;f”）。</p>
<p>受组 “p0” 控制的任务只能从缓存 ID 0 的“下部”50% 和缓存 ID 1 的“上部”50% 进行分配。</p>
<p>组 “p1” 中的任务使用两个插槽上缓存的“下部”50%。</p>
<p>创建监控组并将任务子集分配给每个监控组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># cd /sys/fs/resctrl/p1/mon_groups</span></span><br><span class="line"><span class="meta"># mkdir m11 m12</span></span><br><span class="line"><span class="meta"># echo 5678 &gt; m11/tasks</span></span><br><span class="line"><span class="meta"># echo 5679 &gt; m12/tasks</span></span><br></pre></td></tr></table></figure>

<p>获取数据（数据显示为字节）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># cat m11/mon_data/mon_L3_00/llc_occupancy</span></span><br><span class="line"><span class="number">16234000</span></span><br><span class="line"><span class="meta"># cat m11/mon_data/mon_L3_01/llc_occupancy</span></span><br><span class="line"><span class="number">14789000</span></span><br><span class="line"><span class="meta"># cat m12/mon_data/mon_L3_00/llc_occupancy</span></span><br><span class="line"><span class="number">16789000</span></span><br></pre></td></tr></table></figure>

<p>父 CTRL_MON 组显示聚合数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cat /sys/fs/resctrl/p1/mon_data/mon_l3_00/llc_occupancy</span><br><span class="line"></span><br><span class="line">31234000</span><br></pre></td></tr></table></figure>

<h4 id="示例-2（从任务创建时监控）"><a href="#示例-2（从任务创建时监控）" class="headerlink" title="示例 2（从任务创建时监控）"></a>示例 2（从任务创建时监控）</h4><p>在双插槽机器上（每个插槽一个 L3 缓存）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mount -t resctrl resctrl /sys/fs/resctrl</span></span><br><span class="line"><span class="meta"># cd /sys/fs/resctrl</span></span><br><span class="line"><span class="meta"># mkdir p0 p1</span></span><br></pre></td></tr></table></figure>

<p>一旦创建组，就会为其分配一个 RMID，因此下面的内容会从创建时开始监控。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo $$ &gt; /sys/fs/resctrl/p1/tasks</span><br></pre></td></tr></table></figure>

<p>获取数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># cat /sys/fs/resctrl/p1/mon_data/mon_l3_00/llc_occupancy</span></span><br><span class="line"><span class="number">31789000</span></span><br></pre></td></tr></table></figure>

<h4 id="示例-3（没有-CAT-支持或在创建-CAT-组之前监控）"><a href="#示例-3（没有-CAT-支持或在创建-CAT-组之前监控）" class="headerlink" title="示例 3（没有 CAT 支持或在创建 CAT 组之前监控）"></a>示例 3（没有 CAT 支持或在创建 CAT 组之前监控）</h4><p>假设像 HSW 这样的系统只有 CQM 而没有 CAT 支持 。在这种情况下，resctrl 仍然可以挂载，但无法创建 CTRL_MON 目录。但是用户可以在根组中创建不同的 MON 组，从而能够监控所有任务，包括内核线程。</p>
<p>这也可以用于在将作业分配到不同的分配组之前，分析其缓存大小占用情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mount -t resctrl resctrl /sys/fs/resctrl</span></span><br><span class="line"><span class="meta"># cd /sys/fs/resctrl</span></span><br><span class="line"><span class="meta"># mkdir mon_groups/m01</span></span><br><span class="line"><span class="meta"># mkdir mon_groups/m02</span></span><br><span class="line"><span class="meta"># echo 3478 &gt; /sys/fs/resctrl/mon_groups/m01/tasks</span></span><br><span class="line"><span class="meta"># echo 2467 &gt; /sys/fs/resctrl/mon_groups/m02/tasks</span></span><br></pre></td></tr></table></figure>

<p>单独监控这些组并获取每个域的数据。从下面的结果可以看出，任务主要在域（插槽）0 上进行工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># cat /sys/fs/resctrl/mon_groups/m01/mon_L3_00/llc_occupancy</span></span><br><span class="line"><span class="number">31234000</span></span><br><span class="line"><span class="meta"># cat /sys/fs/resctrl/mon_groups/m01/mon_L3_01/llc_occupancy</span></span><br><span class="line"><span class="number">34555</span></span><br><span class="line"><span class="meta"># cat /sys/fs/resctrl/mon_groups/m02/mon_L3_00/llc_occupancy</span></span><br><span class="line"><span class="number">31234000</span></span><br><span class="line"><span class="meta"># cat /sys/fs/resctrl/mon_groups/m02/mon_L3_01/llc_occupancy</span></span><br><span class="line"><span class="number">32789</span></span><br></pre></td></tr></table></figure>

<h4 id="示例-4（监控实时任务）"><a href="#示例-4（监控实时任务）" class="headerlink" title="示例 4（监控实时任务）"></a>示例 4（监控实时任务）</h4><p>一个单插槽系统，实时任务运行在核心 4-7 上，非实时任务运行在其他 CPU 上。我们希望监控这些核心上实时线程的缓存占用情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mount -t resctrl resctrl /sys/fs/resctrl</span></span><br><span class="line"><span class="meta"># cd /sys/fs/resctrl</span></span><br><span class="line"><span class="meta"># mkdir p1</span></span><br></pre></td></tr></table></figure>

<p>将 CPU 4-7 移到 p1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># echo f0 &gt; p1/cpus</span></span><br></pre></td></tr></table></figure>

<p>查看 llc 占用快照：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># cat /sys/fs/resctrl/p1/mon_data/mon_L3_00/llc_occupancy</span></span><br><span class="line"><span class="number">11234000</span></span><br></pre></td></tr></table></figure>

<h2 id="英特尔-RDT-勘误"><a href="#英特尔-RDT-勘误" class="headerlink" title="英特尔 RDT 勘误"></a>英特尔 RDT 勘误</h2><h3 id="英特尔-MBM-计数器可能错误地报告系统内存带宽"><a href="#英特尔-MBM-计数器可能错误地报告系统内存带宽" class="headerlink" title="英特尔 MBM 计数器可能错误地报告系统内存带宽"></a>英特尔 MBM 计数器可能错误地报告系统内存带宽</h3><p>Skylake 服务器的勘误 SKX99 和 Broadwell 服务器的勘误 BDF102。</p>
<p>问题：英特尔内存带宽监控 (MBM) 计数器根据分配给该逻辑核心的资源监控 ID (RMID) 跟踪指标。用于报告这些指标的 IA32_QM_CTR 寄存器 (MSR 0xC8E) 可能会报告某些 RMID 值的错误系统带宽。</p>
<p>影响：由于勘误，系统内存带宽可能与报告不符。</p>
<p>解决方法：MBM 总量和本地读数根据以下校正因子表进行校正：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|核心数 |RMID 数 |RMID 阈值 |校正因子 |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">1</span> |<span class="number">8</span> |<span class="number">0</span> |<span class="number">1.000000</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">2</span> |<span class="number">16</span> |<span class="number">0</span> |<span class="number">1.000000</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">3</span> |<span class="number">24</span> |<span class="number">15</span> |<span class="number">0.969650</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">4</span> |<span class="number">32</span> |<span class="number">0</span> |<span class="number">1.000000</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">6</span> |<span class="number">48</span> |<span class="number">31</span> |<span class="number">0.969650</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">7</span> |<span class="number">56</span> |<span class="number">47</span> |<span class="number">1.142857</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">8</span> |<span class="number">64</span> |<span class="number">0</span> |<span class="number">1.000000</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">9</span> |<span class="number">72</span> |<span class="number">63</span> |<span class="number">1.185115</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">10</span> |<span class="number">80</span> |<span class="number">63</span> |<span class="number">1.066553</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">11</span> |<span class="number">88</span> |<span class="number">79</span> |<span class="number">1.454545</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">12</span> |<span class="number">96</span> |<span class="number">0</span> |<span class="number">1.000000</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">13</span> |<span class="number">104</span> |<span class="number">95</span> |<span class="number">1.230769</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">14</span> |<span class="number">112</span> |<span class="number">95</span> |<span class="number">1.142857</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">15</span> |<span class="number">120</span> |<span class="number">95</span> |<span class="number">1.066667</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">16</span> |<span class="number">128</span> |<span class="number">0</span> |<span class="number">1.000000</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">17</span> |<span class="number">136</span> |<span class="number">127</span> |<span class="number">1.254863</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">18</span> |<span class="number">144</span> |<span class="number">127</span> |<span class="number">1.185255</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">19</span> |<span class="number">152</span> |<span class="number">0</span> |<span class="number">1.000000</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">20</span> |<span class="number">160</span> |<span class="number">127</span> |<span class="number">1.066667</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">21</span> |<span class="number">168</span> |<span class="number">0</span> |<span class="number">1.000000</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">22</span> |<span class="number">176</span> |<span class="number">159</span> |<span class="number">1.454334</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">23</span> |<span class="number">184</span> |<span class="number">0</span> |<span class="number">1.000000</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">24</span> |<span class="number">192</span> |<span class="number">127</span> |<span class="number">0.969744</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">25</span> |<span class="number">200</span> |<span class="number">191</span> |<span class="number">1.280246</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">26</span> |<span class="number">208</span> |<span class="number">191</span> |<span class="number">1.230921</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">27</span> |<span class="number">216</span> |<span class="number">0</span> |<span class="number">1.000000</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br><span class="line">|<span class="number">28</span> |<span class="number">224</span> |<span class="number">191</span> |<span class="number">1.143118</span> |</span><br><span class="line">+---------------+---------------+---------------+-----------------+</span><br></pre></td></tr></table></figure>

<p>如果 rmid &gt; rmid 阈值，MBM 总量和本地值应乘以校正因子。</p>
<p>参见：</p>
<ol>
<li><p>英特尔至强可扩展家族规范更新中的勘误 SKX99：<br><a target="_blank" rel="noopener" href="http://web.archive.org/web/20200716124958/https://www.intel.com/content/www/us/en/processors/xeon/scalable/xeon-scalable-spec-update.html">http://web.archive.org/web/20200716124958/https://www.intel.com/content/www/us/en/processors/xeon/scalable/xeon-scalable-spec-update.html</a></p>
</li>
<li><p>英特尔至强 E5-2600 v4 处理器产品家族规范更新中的勘误 BDF102：<br><a target="_blank" rel="noopener" href="http://web.archive.org/web/20191125200531/https://www.intel.com/content/dam/www/public/us/en/documents/specification-updates/xeon-e5-v4-spec-update.pdf">http://web.archive.org/web/20191125200531/https://www.intel.com/content/dam/www/public/us/en/documents/specification-updates/xeon-e5-v4-spec-update.pdf</a></p>
</li>
<li><p>第 2 代英特尔至强可扩展处理器参考手册中的英特尔资源导向技术 (Intel RDT) 勘误：<br><a target="_blank" rel="noopener" href="https://software.intel.com/content/www/us/en/develop/articles/intel-resource-director-technology-rdt-reference-manual.html%E4%BB%A5%E8%8E%B7%E5%8F%96%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF%E3%80%82">https://software.intel.com/content/www/us/en/develop/articles/intel-resource-director-technology-rdt-reference-manual.html以获取更多信息。</a></p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/x86/resctrl.rst">https://www.kernel.org/doc/Documentation/x86/resctrl.rst</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wodemia/p/17745666.html">https://www.cnblogs.com/wodemia/p/17745666.html</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ray-jk-hong.github.io">ray.jk.hong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ray-jk-hong.github.io/2025/07/25/linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%B8%A6%E5%AE%BD/">https://ray-jk-hong.github.io/2025/07/25/linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%B8%A6%E5%AE%BD/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ray-jk-hong.github.io" target="_blank">ray.jk.hong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a></div><div class="post-share"><div class="social-share" data-image="/blog/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/blog/2025/07/24/linux/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ext/" title="ext文件系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">ext文件系统</div></div><div class="info-2"><div class="info-item-1">创建挂载文件系统创建文件按如下命令创建1GB的文件： 1dd if=/dev/zero of=./ext4_image.img bs=1M count=1024  格式化按如下命令将文件格式化成ext4文件系统： 1mkfs.ext4 ext4_image.img  挂载文件系统通过Linux的loop虚拟设备将文件挂载到目录上： 1sudo mount -o loop ext4_image.img /home/biao/test/ext4/ext4_simulator  查看文件系统信息按照如下命令、将挂载之后的文件系统文件信息打印出来： 1dumpe2fs ext4_image.img  执行之后内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576dumpe2fs 1.44.1 (24-Mar-2018)Filesystem...</div></div></div></a><a class="pagination-related" href="/blog/2025/07/26/linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Kmemleak/" title="Kmemleak"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Kmemleak</div></div><div class="info-2"><div class="info-item-1">原理kmemleak(kernel memory leak detector)是检测内核空间的内存泄漏的调试工具。检测对象是memblock_alloc&#x2F;kmalloc&#x2F;vmalloc&#x2F;kmem_cache_alloc等函数分配的内存块、在分配内存的时候会创建struct kmemleak_object（内部存放申请的地址、大小、call stack等信息）并将其放入红黑树中、等释放的时候将其删除。kmemleak原理是通过扫描整个内存和进程的stack（进程stack是否扫描要额外开启）中的内容与struct...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/blog/2025/07/26/linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Kmemleak/" title="Kmemleak"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-26</div><div class="info-item-2">Kmemleak</div></div><div class="info-2"><div class="info-item-1">原理kmemleak(kernel memory leak detector)是检测内核空间的内存泄漏的调试工具。检测对象是memblock_alloc&#x2F;kmalloc&#x2F;vmalloc&#x2F;kmem_cache_alloc等函数分配的内存块、在分配内存的时候会创建struct kmemleak_object（内部存放申请的地址、大小、call stack等信息）并将其放入红黑树中、等释放的时候将其删除。kmemleak原理是通过扫描整个内存和进程的stack（进程stack是否扫描要额外开启）中的内容与struct...</div></div></div></a><a class="pagination-related" href="/blog/2025/07/22/linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Swap%E7%AE%A1%E7%90%86/" title="Swap管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-22</div><div class="info-item-2">Swap管理</div></div><div class="info-2"><div class="info-item-1">介绍Linux进程申请的匿名页，shm都是没有磁盘文件做支撑（类似Page Cache），在内存紧张需要释放的时候，不能像Page Cache一样拷贝到磁盘文件中释放，所以就有了Swap（交换）机制。 Linux使用交换机制主要基于两个关键原因：第一，它扩展了进程可使用的内存容量。通过虚拟内存和交换空间，即使进程只有部分驻留内存，大型程序仍可运行。通过将”旧”页面换出，寻址的内存总量可轻松超过物理内存，因为按需分页机制会在需要时重新加载这些页面。 第二，即使物理内存充足，交换仍有必要。进程初始化阶段引用的许多页面可能在后续运行中不再使用。将这些页面换出以释放内存用于磁盘缓存，比让它们闲置在内存中更为高效。 需要强调的是，交换并非没有缺点，最显著的缺点是：磁盘速度极慢。如果进程频繁访问大量内存，无论使用多大交换空间或昂贵的高性能磁盘，都无法使其在合理时间内运行，唯有增加物理内存才能解决问题。正因如此，正确选择换出页面以及将相关页面集中存储在交换区显得尤为重要。 怎么选择需要被换出的页需要专门讲，这一篇只说交换机制。 Swap应用创建销毁操作添加一个 交换分区 或添加一个交换文件...</div></div></div></a><a class="pagination-related" href="/blog/2025/07/22/linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/memory%20layout/" title="memory layout"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-22</div><div class="info-item-2">memory layout</div></div><div class="info-2"><div class="info-item-1">内存布局（Memory Layout）memory layout是linux系统看到的整个虚拟地址的布局，对于理解linux内存很重要。下面我们以4K page大小 + 4级页表为例，看一下每一块的起始地址和大小都是哪里定义的。4K page + 4级页表的AArch64 Linux的memory layout如下： 12345678910111213 Start			End			Size		Use ----------------------------------------------------------------------- 0000000000000000	0000ffffffffffff	 256TB		user ffff000000000000	ffff7fffffffffff	 128TB		kernel logical memory map[ffff600000000000	ffff7fffffffffff]	  32TB		[kasan shadow region] ffff800000000000	ffff80007fffffff	  ...</div></div></div></a><a class="pagination-related" href="/blog/2025/07/22/linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" title="内存模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-22</div><div class="info-item-2">内存模型</div></div><div class="info-2"><div class="info-item-1">这里所谓的内存模型，其实就是将struct page结构体在linux内存中怎么进行保存。linux中提供了几种。 CONFIG_FLATMEMFLATMEM仅能够用于物理内存连续的场景，且不支持NUMA，不支持内存热插拔。这种模型下，所有的struct page都保存在mem_map开始的数组中。代码如下： 123#define __pfn_to_page(pfn)	(mem_map + ((pfn) - ARCH_PFN_OFFSET))#define __page_to_pfn(page)	((unsigned long)((page) - mem_map) + \				 ARCH_PFN_OFFSET) ARCH_PFN_OFFSET 定义了物理内存起始地址不同于0的系统的第一个页框号。 mem_map的初始化在mm/mm_init.c文件的alloc_node_mem_map函数中。 1234567// mm/mm_init.c文件#ifdef CONFIG_FLATMEMstatic void __init alloc_node_mem_map(struct...</div></div></div></a><a class="pagination-related" href="/blog/2025/07/22/linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/" title="内存回收"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-22</div><div class="info-item-2">内存回收</div></div><div class="info-2"><div class="info-item-1">回收算法目标页选择   页类型 描述 回收流程    无法回收 1. Free Pages：已经在buddy链表中的空闲页）2. Reserved Pages：PG_reserved flag被设置的页3. 被动态分配出去的页：例如kmalloc或者slub接口分配出去的页4. 进程在内核态的栈对应的页5. 临时被设置了锁的页：就是设置了PG_locked flag的6. 虚拟内存被锁的页：就是调用mlock等、设置了VM_LOCKED flag的    可交换(Swappable) 1. 用户态调用malloc等方式申请的匿名页2. 通过映射tmpfs文件系统申请的页：例如IPC共享内存等3. 将页内容保存到Swap Area   可同步（Syncable） 1. 包含在Page Cache中的的页2. 块设备的buffer pages（buffer_head内存） 将页同步回文件系统文件中   可丢弃（Discardable） 1. 已经被分配缓存、但还没有被使用的（例如 slub cache）2. 没有使用的Dentry Cache 直接释放即可   LRU（Least...</div></div></div></a><a class="pagination-related" href="/blog/2025/07/22/linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%9D%E5%A7%8B%E5%8C%96/" title="物理内存初始化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-22</div><div class="info-item-2">物理内存初始化</div></div><div class="info-2"><div class="info-item-1">介绍这篇主要看在系统启动阶段是怎么决定内存范围，并一步一步启动到伙伴系统这一步的。 物理DDR大小，信息查询下面介绍几种，可以查看DDR频率，大小等信息的方式。在配置完内存之后，查看内存大小频率信息是否符合。 DMI (Desktop Management Interface, DMI)使用DMI命令查询DDR等内存信息，需要使能SMBIOS。否则显示查不到。 12# dmidecode 3.2# No SMBIOS nor DMI entry point found, sorry.  使用DMI查看内存频率大小的命令为：sudo dmidecode --type memory dmidecode源码在https://github.com/mirror/dmidecode/blob/master/dmidecode.c。内核源码在drivers/firmware/dmi_xx中。读取这些内容还依赖内核打开CONFIG_EFI，这与UEFI息息相关。这块内容会单独写一篇。 lshwsudo lshw -class...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/blog/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">ray.jk.hong</div><div class="author-info-description"></div><div class="site-data"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ray-jk-hong"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#info%E7%9B%AE%E5%BD%95"><span class="toc-number">2.</span> <span class="toc-text">info目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-resource%E5%AD%90%E7%9B%AE%E5%BD%95"><span class="toc-number">2.1.</span> <span class="toc-text">Cache resource子目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-bandwidth-MB-%E5%AD%90%E7%9B%AE%E5%BD%95"><span class="toc-number">2.2.</span> <span class="toc-text">Memory bandwidth(MB)子目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%92%8C%E7%9B%91%E6%8E%A7%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text">资源分配和监控组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resource-Allocation-rules-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-number">4.</span> <span class="toc-text">Resource Allocation rules(资源分配规则)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%A6%E5%AE%BD%E5%88%86%E9%85%8D%E5%92%8C%E7%9B%91%E6%8E%A7"><span class="toc-number">5.</span> <span class="toc-text">内存带宽分配和监控</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#L3-schemata-%E6%96%87%E4%BB%B6%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%EF%BC%88%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E4%BC%98%E5%85%88%E7%BA%A7%E7%A6%81%E7%94%A8%EF%BC%89%EF%BC%9A"><span class="toc-number">5.1.</span> <span class="toc-text">L3 schemata 文件详细信息（代码和数据优先级禁用）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L3-schemata-%E6%96%87%E4%BB%B6%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%EF%BC%88%E9%80%9A%E8%BF%87%E6%8C%82%E8%BD%BD%E9%80%89%E9%A1%B9%E5%90%AF%E7%94%A8-CDP-%E5%88%B0-resctrl%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">L3 schemata 文件详细信息（通过挂载选项启用 CDP 到 resctrl）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L2-schemata-%E6%96%87%E4%BB%B6%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="toc-number">5.3.</span> <span class="toc-text">L2 schemata 文件详细信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%A6%E5%AE%BD%E5%88%86%E9%85%8D%EF%BC%88%E9%BB%98%E8%AE%A4%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">内存带宽分配（默认模式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%A6%E5%AE%BD%E5%88%86%E9%85%8D%E4%BB%A5-MBps-%E6%8C%87%E5%AE%9A"><span class="toc-number">5.5.</span> <span class="toc-text">内存带宽分配以 MBps 指定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E9%80%9F%E5%86%85%E5%AD%98%E5%B8%A6%E5%AE%BD%E5%88%86%E9%85%8D-SMBA"><span class="toc-number">5.6.</span> <span class="toc-text">慢速内存带宽分配 (SMBA)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96-%E5%86%99%E5%85%A5-schemata-%E6%96%87%E4%BB%B6"><span class="toc-number">5.7.</span> <span class="toc-text">读取&#x2F;写入 schemata 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96-%E5%86%99%E5%85%A5-schemata-%E6%96%87%E4%BB%B6%EF%BC%88%E5%9C%A8-AMD-%E7%B3%BB%E7%BB%9F%E4%B8%8A%EF%BC%89"><span class="toc-number">5.8.</span> <span class="toc-text">读取&#x2F;写入 schemata 文件（在 AMD 系统上）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96-%E5%86%99%E5%85%A5-schemata-%E6%96%87%E4%BB%B6%EF%BC%88%E5%9C%A8-AMD-%E7%B3%BB%E7%BB%9F%E4%B8%8A%EF%BC%89%E4%B8%8E-SMBA-%E5%8A%9F%E8%83%BD"><span class="toc-number">5.9.</span> <span class="toc-text">读取&#x2F;写入 schemata 文件（在 AMD 系统上）与 SMBA 功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%BC%AA%E9%94%81%E5%AE%9A"><span class="toc-number">6.</span> <span class="toc-text">缓存伪锁定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%BC%AA%E9%94%81%E5%AE%9A%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.1.</span> <span class="toc-text">缓存伪锁定接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%BC%AA%E9%94%81%E5%AE%9A%E8%B0%83%E8%AF%95%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.2.</span> <span class="toc-text">缓存伪锁定调试接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E8%B0%83%E8%AF%95%E6%8E%A5%E5%8F%A3%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.3.</span> <span class="toc-text">延迟调试接口示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD-%E6%9C%AA%E5%91%BD%E4%B8%AD%E8%B0%83%E8%AF%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.4.</span> <span class="toc-text">缓存命中&#x2F;未命中调试示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDT-%E5%88%86%E9%85%8D%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.5.</span> <span class="toc-text">RDT 分配用法示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">6.5.1.</span> <span class="toc-text">示例 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">6.5.2.</span> <span class="toc-text">示例 2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">6.5.3.</span> <span class="toc-text">示例 3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">6.5.4.</span> <span class="toc-text">示例 4</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%BC%AA%E9%94%81%E5%AE%9A%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.</span> <span class="toc-text">缓存伪锁定示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E9%94%81%E5%AE%9A"><span class="toc-number">8.</span> <span class="toc-text">应用程序之间的锁定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDT-%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%88%86%E9%85%8D%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.</span> <span class="toc-text">RDT 监控与分配用法示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE"><span class="toc-number">9.1.</span> <span class="toc-text">读取监控数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1%EF%BC%88%E7%9B%91%E6%8E%A7-CTRL-MON-%E7%BB%84%E5%92%8C-CTRL-MON-%E7%BB%84%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%AD%90%E9%9B%86%EF%BC%89"><span class="toc-number">9.1.1.</span> <span class="toc-text">示例 1（监控 CTRL_MON 组和 CTRL_MON 组中的任务子集）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2%EF%BC%88%E4%BB%8E%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E6%97%B6%E7%9B%91%E6%8E%A7%EF%BC%89"><span class="toc-number">9.1.2.</span> <span class="toc-text">示例 2（从任务创建时监控）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3%EF%BC%88%E6%B2%A1%E6%9C%89-CAT-%E6%94%AF%E6%8C%81%E6%88%96%E5%9C%A8%E5%88%9B%E5%BB%BA-CAT-%E7%BB%84%E4%B9%8B%E5%89%8D%E7%9B%91%E6%8E%A7%EF%BC%89"><span class="toc-number">9.1.3.</span> <span class="toc-text">示例 3（没有 CAT 支持或在创建 CAT 组之前监控）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4%EF%BC%88%E7%9B%91%E6%8E%A7%E5%AE%9E%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%89"><span class="toc-number">9.1.4.</span> <span class="toc-text">示例 4（监控实时任务）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8B%B1%E7%89%B9%E5%B0%94-RDT-%E5%8B%98%E8%AF%AF"><span class="toc-number">10.</span> <span class="toc-text">英特尔 RDT 勘误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8B%B1%E7%89%B9%E5%B0%94-MBM-%E8%AE%A1%E6%95%B0%E5%99%A8%E5%8F%AF%E8%83%BD%E9%94%99%E8%AF%AF%E5%9C%B0%E6%8A%A5%E5%91%8A%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%B8%A6%E5%AE%BD"><span class="toc-number">10.1.</span> <span class="toc-text">英特尔 MBM 计数器可能错误地报告系统内存带宽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">11.</span> <span class="toc-text">参考</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>