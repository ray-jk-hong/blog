<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Arm-mmu | ray.jk.hong</title><meta name="author" content="ray.jk.hong"><meta name="copyright" content="ray.jk.hong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MMU负责将虚拟地址转成物理地址。除了地址转换，还可以控制一下几个事情：  内存访问权限控制 内存访问ordering控制 Cache访问策略下面就按照几个功能的来说明，并顺带说明没个功能所涉及的寄存器。  启动阶段配置在完成地址翻译的时候，在启动阶段要确认并配置以下几个寄存器。 TCR_EL寄存器  上图是TCR_EL寄存器的显示图。TCR寄存器的设置在arch&#x2F;arm64&#x2F;mm&#x2F;proc.S的">
<meta property="og:type" content="article">
<meta property="og:title" content="Arm-mmu">
<meta property="og:url" content="https://ray-jk-hong.github.io/2025/07/22/arch/Arm-mmu/index.html">
<meta property="og:site_name" content="ray.jk.hong">
<meta property="og:description" content="MMU负责将虚拟地址转成物理地址。除了地址转换，还可以控制一下几个事情：  内存访问权限控制 内存访问ordering控制 Cache访问策略下面就按照几个功能的来说明，并顺带说明没个功能所涉及的寄存器。  启动阶段配置在完成地址翻译的时候，在启动阶段要确认并配置以下几个寄存器。 TCR_EL寄存器  上图是TCR_EL寄存器的显示图。TCR寄存器的设置在arch&#x2F;arm64&#x2F;mm&#x2F;proc.S的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ray-jk-hong.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-07-22T10:26:20.890Z">
<meta property="article:modified_time" content="2025-07-25T14:12:28.767Z">
<meta property="article:author" content="ray.jk.hong">
<meta property="article:tag" content="芯片架构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ray-jk-hong.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Arm-mmu",
  "url": "https://ray-jk-hong.github.io/2025/07/22/arch/Arm-mmu/",
  "image": "https://ray-jk-hong.github.io/img/butterfly-icon.png",
  "datePublished": "2025-07-22T10:26:20.890Z",
  "dateModified": "2025-07-25T14:12:28.767Z",
  "author": [
    {
      "@type": "Person",
      "name": "ray.jk.hong",
      "url": "https://ray-jk-hong.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="https://ray-jk-hong.github.io/2025/07/22/arch/Arm-mmu/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Arm-mmu',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="/js/bandev.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/blog/"></a><a class="nav-page-title" href="/blog/"><span class="site-name">Arm-mmu</span></a></span><div id="menus"></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Arm-mmu</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-categories"><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/%E8%8A%AF%E7%89%87%E6%9E%B6%E6%9E%84/">芯片架构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><p>MMU负责将虚拟地址转成物理地址。除了地址转换，还可以控制一下几个事情：</p>
<ol>
<li>内存访问权限控制</li>
<li>内存访问ordering控制</li>
<li>Cache访问策略<br>下面就按照几个功能的来说明，并顺带说明没个功能所涉及的寄存器。</li>
</ol>
<h3 id="启动阶段配置"><a href="#启动阶段配置" class="headerlink" title="启动阶段配置"></a>启动阶段配置</h3><p>在完成地址翻译的时候，在启动阶段要确认并配置以下几个寄存器。</p>
<h4 id="TCR-EL寄存器"><a href="#TCR-EL寄存器" class="headerlink" title="TCR_EL寄存器"></a>TCR_EL寄存器</h4><img src="/blog/2025/07/22/arch/Arm-mmu/TCR_ELx%E5%AF%84%E5%AD%98%E5%99%A8.png" class="" title="图片描述">

<p>上图是TCR_EL寄存器的显示图。TCR寄存器的设置在<code>arch/arm64/mm/proc.S</code>的<code>__cpu_setup</code>函数中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov_q	tcr, TCR_TxSZ(VA_BITS) | TCR_CACHE_FLAGS | TCR_SMP_FLAGS | \</span><br><span class="line">		TCR_TG_FLAGS | TCR_KASLR_FLAGS | TCR_ASID16 | \</span><br><span class="line">		TCR_TBI0 | TCR_A1 | TCR_KASAN_SW_FLAGS | TCR_MTE_FLAGS</span><br><span class="line">   ...</span><br><span class="line">   tcr_compute_pa_size tcr, #TCR_IPS_SHIFT, x5, x6</span><br></pre></td></tr></table></figure>

<p>TCR寄存器有以下子寄存器：</p>
<h5 id="TxSZ（有T0SZ-T1SZ两个，统一表示为TxSZ）"><a href="#TxSZ（有T0SZ-T1SZ两个，统一表示为TxSZ）" class="headerlink" title="TxSZ（有T0SZ&#x2F;T1SZ两个，统一表示为TxSZ）"></a>TxSZ（有T0SZ&#x2F;T1SZ两个，统一表示为TxSZ）</h5><p>TxSZ指定使用TTBRx_EL1时的虚拟地址空间大小。虚拟地址有效位数为64 - TxSZ。<br>现在虚拟地址长度指定为48位，TxSZ就要设定为16。TxSZ的长度会影响页表层级（如48位需4级页表）。<br>在Linux中<code>CONFIG_ARM64_VA_BITS</code>宏被用来设置虚拟地址的长度。Linux中提供了几个设置选项。<br>TxSZ设置完之后，会影响哪些地址范围走TTBR0或者TTBR1。例如虚拟地址还是设置为了48位。则T0SZ, T1SZ会被设置为。<br>TCR_EL1.T0SZ &#x3D; 16 (64-48)  &#x2F;&#x2F; 用户空间使用低 48 位地址<br>TCR_EL1.T1SZ &#x3D; 16 (64-48)  &#x2F;&#x2F; 内核空间使用高 48 位地址<br>这样配置后：<br>地址范围 0x0000_0000_0000_0000 到 0x0000_FFFF_FFFF_FFFF 使用 TTBR0_EL1<br>地址范围 0xFFFF_0000_0000_0000 到 0xFFFF_FFFF_FFFF_FFFF 使用 TTBR1_EL1<br>TxSZ的设置如下，其中VA_BITS是设置的虚拟地址占用的bit位。例如在linux arm64中如果配置<code>CONFIG_ARM64_VA_BITS_48=y``CONFIG_ARM64_VA_BITS=48</code>的话<code>VA_BITS</code>就是48了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov_q	tcr, TCR_TxSZ(VA_BITS) | ...</span><br><span class="line">...</span><br><span class="line">tcr_compute_pa_size tcr, #TCR_IPS_SHIFT, x5, x6</span><br></pre></td></tr></table></figure>

<h5 id="IPS-Intermediate-Physical-Address-Size"><a href="#IPS-Intermediate-Physical-Address-Size" class="headerlink" title="IPS(Intermediate Physical Address Size)"></a>IPS(Intermediate Physical Address Size)</h5><p>在上面的<code>tcr_compute_pa_size tcr, #TCR_IPS_SHIFT, x5, x6</code>中设置IPS的值。<br>IPS 值与虚拟地址位数（VA_BITS）无关，而是取决于处理器支持的物理地址位数（通过读ID_AA64MMFR0_EL1的PARange确定）。<br>IPS的值可以被设置为以下几个：</p>
<ul>
<li>000b: 32 位物理地址 (4GB)</li>
<li>001b: 36 位物理地址 (64GB)</li>
<li>010b: 40 位物理地址 (1TB)</li>
<li>011b: 42 位物理地址 (4TB)</li>
<li>100b: 44 位物理地址 (16TB)</li>
<li>101b: 48 位物理地址 (256TB)</li>
<li>110b: 52 位物理地址 (4PB)<br>所以IPS的值是软件不能根据配置进行修改的。</li>
</ul>
<h5 id="TGx（TG0-TG1）"><a href="#TGx（TG0-TG1）" class="headerlink" title="TGx（TG0&#x2F;TG1）"></a>TGx（TG0&#x2F;TG1）</h5><p>表示页的大小。还是在上述的<code>__cpu_setup</code>函数中设置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM64_64K_PAGES</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCR_TG_FLAGS	TCR_TG0_64K | TCR_TG1_64K</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_ARM64_16K_PAGES)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCR_TG_FLAGS	TCR_TG0_16K | TCR_TG1_16K</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* CONFIG_ARM64_4K_PAGES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCR_TG_FLAGS	TCR_TG0_4K | TCR_TG1_4K</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	mov_q	tcr, ... | \</span><br><span class="line">			TCR_TG_FLAGS | ... | \</span><br></pre></td></tr></table></figure>
<p>TG1&#x2F;TG0都占用两个bit位，可以设置下列几种值，每个值代表一种page大小。<br>00：页大小是4KB<br>10：页大小是16KB<br>11：页大小是64KB</p>
<h5 id="ORGNx-IRGNx"><a href="#ORGNx-IRGNx" class="headerlink" title="ORGNx, IRGNx"></a>ORGNx, IRGNx</h5><p>这个寄存器表示页表遍历的缓存属性。ARM64统一都使用了<code>WBWA - Write-Back Write-Allocate</code>属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCR_CACHE_FLAGS	TCR_IRGN_WBWA | TCR_ORGN_WBWA</span></span><br><span class="line">	mov_q	tcr, ... | TCR_CACHE_FLAGS | ... </span><br></pre></td></tr></table></figure>
<p><code>Write-Back Write-Allocate</code>是什么Cache属性，查看Cache那篇。</p>
<h5 id="SHx"><a href="#SHx" class="headerlink" title="SHx"></a>SHx</h5><p>表示多处理器系统中的共享属性。</p>
<ul>
<li>0b00: 非共享（Non-shareable）<br>0b10: 外部共享（Outer Shareable）<br>0b11: 内部共享（Inner Shareable）<br>ARM64中默认都是设置成了内部共享。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCR_SH0_INNER		(UL(3) &lt;&lt; TCR_SH0_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCR_SH1_INNER		(UL(3) &lt;&lt; TCR_SH1_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCR_SHARED		(TCR_SH0_INNER | TCR_SH1_INNER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCR_SMP_FLAGS	TCR_SHARED</span></span><br><span class="line">	mov_q	tcr, ... | TCR_SMP_FLAGS | ... </span><br></pre></td></tr></table></figure>

<h5 id="AS"><a href="#AS" class="headerlink" title="AS"></a>AS</h5><p>设置ASID的size。该值是0表示使用8bit，1表示使用16bit。ARM64默认填的是16</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov_q	tcr, ... | TCR_ASID16 | ... </span><br></pre></td></tr></table></figure>
<h5 id="A1"><a href="#A1" class="headerlink" title="A1"></a>A1</h5><p>决定ASID存储在TTBR0还是TTBR1中</p>
<ul>
<li>0: 存储在TTBR0_EL1.ASID中</li>
<li>1: 存储在TTBR1_EL1.ASID中<br>ARM64中是默认配置成了1.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov_q	tcr, ... | TCR_A1 | ... </span><br></pre></td></tr></table></figure>

<h5 id="TCR中54bit"><a href="#TCR中54bit" class="headerlink" title="TCR中54bit"></a>TCR中54bit</h5><p>用来保存是否支持随机地址（KASL）这种安全属性。这个是根据内核的<code>CONFIG_RANDOMIZE_BASE</code>属性是否打开决定的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RANDOMIZE_BASE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCR_KASLR_FLAGS	TCR_NFD1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCR_KASLR_FLAGS	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    mov_q	tcr, ... | TCR_KASLR_FLAGS | ... </span><br></pre></td></tr></table></figure>

<h5 id="TBI1-TBID1-TBID1上面的图中没有，代码中是保存在52bit"><a href="#TBI1-TBID1-TBID1上面的图中没有，代码中是保存在52bit" class="headerlink" title="TBI1, TBID1 (TBID1上面的图中没有，代码中是保存在52bit)"></a>TBI1, TBID1 (TBID1上面的图中没有，代码中是保存在52bit)</h5><p>是否让TTBR1_EL1忽略虚拟地址的高8位，用于支持地址标签（如ARMv8.5的MTE或者KASAN）。<br>TBIx的设置是根据内核是否打开了KASAN或者是MTE设置的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN_SW_TAGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCR_KASAN_SW_FLAGS TCR_TBI1 | TCR_TBID1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCR_KASAN_SW_FLAGS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN_HW_TAGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCR_MTE_FLAGS TCR_TCMA1 | TCR_TBI1 | TCR_TBID1</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_ARM64_MTE)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The mte_zero_clear_page_tags() implementation uses DC GZVA, which relies on</span></span><br><span class="line"><span class="comment"> * TBI being enabled at EL1.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCR_MTE_FLAGS TCR_TBI1 | TCR_TBID1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCR_MTE_FLAGS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    mov_q	tcr, ... | TCR_KASAN_SW_FLAGS | TCR_MTE_FLAGS | ... </span><br></pre></td></tr></table></figure>

<h5 id="TBI0"><a href="#TBI0" class="headerlink" title="TBI0"></a>TBI0</h5><p>是否让TTBR0_EL1忽略虚拟地址的高8位。ARM64中是默认忽略的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov_q	tcr, ... | TCR_TBI0 | ... </span><br></pre></td></tr></table></figure>

<h5 id="HD"><a href="#HD" class="headerlink" title="HD"></a>HD</h5><p>只有在armv8-a&#x2F;aarch64场景支持。启用或禁用硬件对脏页（<code>PTE_DIRTY</code>）的自动管理功能。<br><code>ECR_ELx.HD=1</code>、<code>DBM=1</code>表示开启（查看下文中的页表属性）。</p>
<h5 id="HA"><a href="#HA" class="headerlink" title="HA"></a>HA</h5><p>只有在armv8-a&#x2F;aarch64场景支持。启用或禁用硬件对访问标志（Access Flag, AF）的自动管理功能。</p>
<h4 id="MAIR-ELn"><a href="#MAIR-ELn" class="headerlink" title="MAIR_ELn"></a>MAIR_ELn</h4><p>MAIR_EL是一个64位寄存器，包含8个8位的属性字段（Attr0-Attr7），每个字段对应一个内存属性配置索引（0-7）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAIR_ATTRIDX(attr, idx)		((attr) &lt;&lt; ((idx) * 8))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIR_ATTR_DEVICE_nGnRnE		UL(0x00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIR_ATTR_DEVICE_nGnRE		UL(0x04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIR_ATTR_NORMAL_NC		UL(0x44)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIR_ATTR_NORMAL_TAGGED		UL(0xf0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIR_ATTR_NORMAL		UL(0xff)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIR_ATTR_MASK			UL(0xff)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MT_NORMAL		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MT_NORMAL_TAGGED	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MT_NORMAL_NC		2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MT_DEVICE_nGnRnE	3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MT_DEVICE_nGnRE		4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Default MAIR_EL1. MT_NORMAL_TAGGED is initially mapped as Normal memory and</span></span><br><span class="line"><span class="comment"> * changed during mte_cpu_setup to Normal Tagged if the system supports MTE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIR_EL1_SET							\</span></span><br><span class="line"><span class="meta">	(MAIR_ATTRIDX(MAIR_ATTR_DEVICE_nGnRnE, MT_DEVICE_nGnRnE) |	\</span></span><br><span class="line"><span class="meta">	 MAIR_ATTRIDX(MAIR_ATTR_DEVICE_nGnRE, MT_DEVICE_nGnRE) |	\</span></span><br><span class="line"><span class="meta">	 MAIR_ATTRIDX(MAIR_ATTR_NORMAL_NC, MT_NORMAL_NC) |		\</span></span><br><span class="line"><span class="meta">	 MAIR_ATTRIDX(MAIR_ATTR_NORMAL, MT_NORMAL) |			\</span></span><br><span class="line"><span class="meta">	 MAIR_ATTRIDX(MAIR_ATTR_NORMAL, MT_NORMAL_TAGGED))</span></span><br><span class="line">    mov_q	mair, MAIR_EL1_SET</span><br></pre></td></tr></table></figure>
<p>Linux arm64上，配置了attr0-attr4，每个attr占用8个bit，按低4位和高4位配置内存类型和cache属性。<br>低4位：定义内存类型（Memory Type），如普通内存（Normal Memory）或设备内存（Device Memory）。<br>高4位：定义内存属性（Memory Attributes），如缓存策略。<br>Normal属性的Cache, Non-Cacheable不用多说。Device属性中的G, R, E分别表示：</p>
<ul>
<li>Gathering (G): 是否允许合并多个访问（0&#x3D;禁止，1&#x3D;允许）。</li>
<li>Reordering (R): 是否允许重排访问顺序（0&#x3D;禁止，1&#x3D;允许）。</li>
<li>Early Write Acknowledgement (E): 是否允许提前确认写操作完成（0&#x3D;禁止，1&#x3D;允许）。</li>
</ul>
<p>那配置了MAIR_ELn这些属性到底有什么用？<br><strong>用处是在，地址翻译的时候，页表项中的AttrIndx字段会引用这些索引，以确定具体的内存属性。</strong></p>
<h4 id="TTBCR"><a href="#TTBCR" class="headerlink" title="TTBCR"></a>TTBCR</h4><p>TTBCR寄存器再arm64上已经不再使用。</p>
<h4 id="TTBR0-EL1-TTBR1-EL1"><a href="#TTBR0-EL1-TTBR1-EL1" class="headerlink" title="TTBR0_EL1, TTBR1_EL1"></a>TTBR0_EL1, TTBR1_EL1</h4><p>准备完上面的寄存器之后，在打开mmu之前要先设置好TTBR0_EL1和TTBR1_EL1。因为一旦mmu打开，按照上面的配置，后续的内核代码就会mmu进行地址翻译。<br>在启动阶段，TTBR0_EL1和TTBR1_EL1会经过以下几次的变化。</p>
<ol>
<li>reserved_pg_dir和init_idmap_pg_dir会被设置到TTBR1_EL1和TTBR0_EL1。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm64/kernel/head.S</span></span><br><span class="line">SYM_FUNC_START_LOCAL(__primary_switch)</span><br><span class="line">	adrp	x1, reserved_pg_dir</span><br><span class="line">	adrp	x2, init_idmap_pg_dir</span><br><span class="line">	bl	__enable_mmu</span><br><span class="line">	...</span><br><span class="line">	bl	clear_page_tables</span><br><span class="line">	bl	create_kernel_mapping</span><br></pre></td></tr></table></figure>
<p>reserved_pg_dir就是一个空白的内存地址。因为这个时候访问的地址还是0x0000abcd这种地址，所以都是在访问TTBR0_EL1，TTBR1_EL1随便设置什么其实都无所谓了。</p>
<p>init_idmap_pg_dir初始化在下面函数中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SYM_FUNC_START_LOCAL(create_idmap)</span><br><span class="line">	...</span><br><span class="line">	adrp	x0, init_idmap_pg_dir</span><br><span class="line">	adrp	x1, init_idmap_pg_end</span><br><span class="line">	map_memory x0, x1, x5, x6, x7, x3, (VA_BITS - PGDIR_SHIFT), x10, x11, x12, x13, x14</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>准备TTBR1_EL1的页表<br>在如下流程中，linux内核先在<code>init_pg_dir</code>中创建页表，后又将<code>init_pg_dir</code>拷贝给<code>swapper_pg_dir</code>，最终将<code>swapper_pg_dir</code>设置给TTBR1_EL1。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__primary_switch</span><br><span class="line">    -&gt;__pi_early_map_kernel(调用early_map_kernel)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">early_map_kernel</span><br><span class="line">    va_base = KIMAGE_VADDR + kaslr_offset;</span><br><span class="line">    map_kernel(kaslr_offset, va_base - pa_base, root_level);</span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="type">void</span> *)swapper_pg_dir + va_offset, init_pg_dir, PAGE_SIZE);</span><br><span class="line">	dsb(ishst);</span><br><span class="line">	idmap_cpu_replace_ttbr1(swapper_pg_dir);</span><br></pre></td></tr></table></figure>
<p>这时候设置的虚拟地址是MODULE_END开始的地址，只是借用一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KIMAGE_VADDR		(MODULES_END)</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>高位地址跳转<br>高位地址的页表已经建好（init_pg_dir）并设置到了TTBR1_EL1中。那内核就可以从低位地址跳转到高位地址了。<br>跳转就是在下面做的。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYM_FUNC_START_LOCAL(__primary_switch)</span><br><span class="line">	...</span><br><span class="line">	ldr	x8, =__primary_switched</span><br><span class="line">	adrp	x0, KERNEL_START		<span class="comment">// __pa(KERNEL_START)</span></span><br><span class="line">	br	x8	</span><br></pre></td></tr></table></figure>
<p>上面语句中<code>ldr	x8, =__primary_switched</code>就是将<code>__primary_switched</code>函数的高位地址（也就是编译器指定的地址）加载到x8中。<code>br x8</code>就是真正跳转到高位地址的一句了。</p>
<h4 id="SCTLR-EL1"><a href="#SCTLR-EL1" class="headerlink" title="SCTLR_EL1"></a>SCTLR_EL1</h4><p>在MMU准备好之后，就会在上述<code>__cpu_setup</code>函数最后，将INIT_SCTRL_EL1_MMU_ON赋值给x0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_SCTLR_EL1_MMU_ON \</span></span><br><span class="line"><span class="meta">	(SCTLR_ELx_M      | SCTLR_ELx_C      | SCTLR_ELx_SA    | \</span></span><br><span class="line"><span class="meta">	 SCTLR_EL1_SA0    | SCTLR_EL1_SED    | SCTLR_ELx_I     | \</span></span><br><span class="line"><span class="meta">	 SCTLR_EL1_DZE    | SCTLR_EL1_UCT    | SCTLR_EL1_nTWE  | \</span></span><br><span class="line"><span class="meta">	 SCTLR_ELx_IESB   | SCTLR_EL1_SPAN   | SCTLR_ELx_ITFSB | \</span></span><br><span class="line"><span class="meta">	 ENDIAN_SET_EL1   | SCTLR_EL1_UCI    | SCTLR_EL1_EPAN  | \</span></span><br><span class="line"><span class="meta">	 SCTLR_EL1_LSMAOE | SCTLR_EL1_nTLSMD | SCTLR_EL1_EIS   | \</span></span><br><span class="line"><span class="meta">	 SCTLR_EL1_TSCXT  | SCTLR_EL1_EOS)</span></span><br><span class="line"></span><br><span class="line">    mov_q	x0, INIT_SCTLR_EL1_MMU_ON</span><br></pre></td></tr></table></figure>
<p>然后在<code>__primary_switch</code>-&gt;<code>__enable_mmu</code>中打开设置x0给sctlr_el1打开mmu。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYM_FUNC_START(__enable_mmu)</span><br><span class="line">...</span><br><span class="line">set_sctlr_el1	x0</span><br><span class="line">SYM_FUNC_END(__enable_mmu)</span><br></pre></td></tr></table></figure>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><h4 id="页表的层级"><a href="#页表的层级" class="headerlink" title="页表的层级"></a>页表的层级</h4><p>页表的层级，是通过设置的VA_BITS和页的大小自动推导，并生成一个CFG_PGTABLE_LEVELS。推导的方式如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># arch/arm64/Kconfig</span><br><span class="line">config PGTABLE_LEVELS</span><br><span class="line">  int</span><br><span class="line">  default 4 if ARM64_4K_PAGES &amp;&amp; ARM64_VA_BITS_48</span><br><span class="line">  default 3 if ARM64_64K_PAGES &amp;&amp; ARM64_VA_BITS_48</span><br><span class="line">  default 3 if ARM64_16K_PAGES &amp;&amp; ARM64_VA_BITS_47</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>之所以需要CFG_PGTABLE_LEVELS是因为Linux要在编译时确定页表结构，主要是以下几个方面：<br>1.代码生成：内核的页表操作代码（如pgd_offset、pud_offset等宏）需要根据层级数展开。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4级页表时展开为4层遍历，3级页表时跳过PUD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_offset(mm, addr)  ((mm)-&gt;pgd + pgd_index(addr))</span></span><br></pre></td></tr></table></figure>
<p>若层级数在编译时不确定，这些宏和函数无法正确生成。<br>2.编译时需要确定数据结构大小<br>类型定义：页表条目类型（如pgd_t、pud_t）的大小和结构需在编译时确定。例如，3级页表可能省略pud_t的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 3</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">pudval_t</span> pud; &#125; <span class="type">pud_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>3.性能优化<br>循环展开：页表遍历代码（如walk_page_range）可通过编译时已知的层级数进行循环展开，减少分支判断。<br>内联优化：固定层级数允许编译器对页表操作函数进行深度内联优化。<br>4.硬件兼容<br>支持多种配置：不同ARM64处理器可能支持不同的页表层级（如某些定制芯片可能强制3级），需通过配置项适配。</p>
<p>在Linux中，按照页表层级，分别有如下：<br>4层页表结构：PGD, PUD, PMD, PTE<br>3层页表结构：PGD, PMD, PTE</p>
<h4 id="页表的结构"><a href="#页表的结构" class="headerlink" title="页表的结构"></a>页表的结构</h4>
<p>上面的图是经常看到的页表的类型。这几种页表类型，是根据最后两位区分的。<br>x0: 最后一位是0表示这是无效页表。mmu在访问到的这里的时候会发生缺页。<br>01: 表示是block entry。这种是直接映射大块物理内存（如1GB&#x2F;2MB）。mmu发现最后两位是01的时候就会停止扫描，直接翻译物理地址了。<br>这种不是用来映射一般page的，是用于映射大页或者更大的范围的。我们知道的大页（hugetlb）就是使用这种方式建的页表（2MB）。在4级页表场景下，大页只需要使用3级页表，可以减少TLB miss提高性能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 设置block entry的可以搜一下如下函数中的PROT_SECT_NORMAL或者pmd_set_huge再仔细看一下。</span><br><span class="line">pmd_set_huge(pmdp, __pa(p), __pgprot(PROT_SECT_NORMAL));</span><br></pre></td></tr></table></figure>

<p>11: 这种就是Table descriptor或者Table entry<br>之所以叫的名字不一样，是因为他们指向的内容不一样。Table descriptor是说指向下一级页表的，Table entry是指向一个物理地址的（一般就是指向一个page）。<br>那一样都是11，mmu怎么知道是什么类型的呢？<br>答案是mmu根据上述TCR寄存器中的配置内容，知道当前用的是几级页表的。如果没有到最后一级页表，发现最后两位是11，那就是按Table descriptor解析，找到下一级页表。<br>但发现已经到了最后一级页表，就会按照Table entry的格式解析翻译地址了。</p>
<p>在4级页表，4KB页表大小的场景，每级页表对应的页表类型和mmu的行为如下。</p>
<ul>
<li><p>映射4K页表：<br>页表翻译流程：PGD → Table Descriptor → PUD → Table Descriptor → PMD → Table Descriptor → PTE → Page Entry（4KB 页）。<br>MMU 行为：在 PMD 层看到 0b01，直接映射 2MB 块，停止遍历</p>
</li>
<li><p>映射2MB大页：<br>页表翻译流程：PGD → Table Descriptor → PUD → Table Descriptor → PMD → Block Entry（低两位为 0b01）<br>MMU 行为：在 PMD 层看到 0b01，直接映射 2MB 块，停止遍历</p>
</li>
</ul>
<h4 id="页表属性"><a href="#页表属性" class="headerlink" title="页表属性"></a>页表属性</h4><p>上一节中，block entry, table entry中，都有一些bit为是用来表示需要访问的物理地址的访问属性的。这些属性，如下图所示：</p>
<img src="/blog/2025/07/22/arch/Arm-mmu/%E9%A1%B5%E8%A1%A8%E5%B1%9E%E6%80%A7.png" class="" title="图片描述">

<p>下面就说明这些bit为各表示什么。</p>
<h5 id="UXN-XN-置1表示用户态没有执行权限。"><a href="#UXN-XN-置1表示用户态没有执行权限。" class="headerlink" title="UXN&#x2F;XN: 置1表示用户态没有执行权限。"></a>UXN&#x2F;XN: 置1表示用户态没有执行权限。</h5><p><code>#define PTE_UXN (_AT(pteval_t, 1) &lt;&lt; 54)	/* User XN */</code></p>
<h5 id="PXN-置1表示内核态没有执行权限。"><a href="#PXN-置1表示内核态没有执行权限。" class="headerlink" title="PXN: 置1表示内核态没有执行权限。"></a>PXN: 置1表示内核态没有执行权限。</h5><p><code>#define PTE_PXN (_AT(pteval_t, 1) &lt;&lt; 53)</code></p>
<h5 id="Contiguous"><a href="#Contiguous" class="headerlink" title="Contiguous:"></a>Contiguous:</h5><p><code>#define PTE_CONT (_AT(pteval_t, 1) &lt;&lt; 52)</code><br>ARMv8的特性PTE_CONT，表示一段连续的物理页。Linux中使用<code>CONFIG_ARM64_CONT_PTE_SHIFT</code>, <code>CONFIG_ARM64_CONT_PMD_SHIFT</code>来表示多少个PTE和PMD可以绑定成一段连续的物理页。<br>例如CONFIG_ARM64_CONT_PTE_SHIFT是16，且16个连续的PTE页表（也就是最后一级的Table entry，最后一个有时候直接叫Page entry），MMU翻译完页表之后保存结果到TBL的时候只需要保存一条条目即可。<br>当然写PTE_CONT也是有要求的，就是16个4K的连续填PTE_CONT的时候，第一个物理页地址和虚拟地址都是要64KB对齐的。这个在讲大页的时候讲解。</p>
<h5 id="nG"><a href="#nG" class="headerlink" title="nG:"></a>nG:</h5><p><code>#define PTE_NG			(_AT(pteval_t, 1) &lt;&lt; 11)	/* nG */</code></p>
<p>表示页表是否是全局映射。所谓全局映射，就是说页表是否与某个进程相关。<br>nG &#x3D; 1: 表示页表是非全局的。只对当前进程有效。<br>nG &#x3D; 0: 表示页表是全局的，对所有进程都有效。</p>
<p>在内核代码中也可以看到内核的页设置的是nG &#x3D; 0，但映射给用户态的是设置了nG &#x3D; 1。<br>之所以区分全局与否，是为了在进程切换时，决定是否将对应的TLB项删除还是保存。<br>当进程切换时，通过<code>__tlbi(aside1is, asid)</code>指令仅刷新与旧ASID关联的非全局TLB条目。<br>全局TLB条目（如内核页表）无需刷新，保留复用。<br>这样能够改善进程切换的性能。</p>
<h5 id="AF-记录是否被访问过。0表示尚未被访问，1表示已经被访问了。"><a href="#AF-记录是否被访问过。0表示尚未被访问，1表示已经被访问了。" class="headerlink" title="AF: 记录是否被访问过。0表示尚未被访问，1表示已经被访问了。"></a>AF: 记录是否被访问过。0表示尚未被访问，1表示已经被访问了。</h5><p><code>#define PTE_AF (_AT(pteval_t, 1) &lt;&lt; 10)	/* Access Flag */</code></p>
<p>软件通过以下方式管理该标志：<br>当页面首次创建时，其条目中的 AF 位被设为 0。<br>当代码首次访问该页面时，如果其 AF 位为 0，会根据TCR_EL1.HD是否使能会有如下操作。</p>
<ol>
<li>TCR_EL1.HA &#x3D; 0的场景：触发page fault，在page fault流程中将AF位设为1。</li>
<li>TCR_EL1.HA &#x3D; 1的场景：mmu硬件会自动将AF未置上，不会触发page fault。</li>
</ol>
<p>芯片支持，当然就要把HD置上，以免mmap或者malloc出来的地址在第一次访问的时候还会触发page fault，出现性能抖动。<br>这一机制会影响内核内存管理的某些决策，例如：当需要将页面换出内存（swap out）时，该页面从来都没有被访问过，就没有必要swap out的必要，直接将页表删除就可以了。</p>
<h5 id="DBM-51"><a href="#DBM-51" class="headerlink" title="DBM[51]"></a>DBM[51]</h5><p>只在armv8-a&#x2F;aarch64场景支持，用于标记是否使能硬件自动管理脏页标记（PTE_DIRTY）。DBM&#x3D;1表示启用，DBM&#x3D;0表示禁用。<br>软件处理方式是：在建页表的时候初始化为PTE_RDONLY使得第一次写的时候触发缺页，后在异常处理中标记PTE_DIRTY并恢复写权限。<br>硬件优化方案：当TCR_EL1.HD&#x3D;1并设置了PTE_DBM之后，硬件在检测到写操作时自动设置PTE_DIRTY。</p>
<h5 id="SH-1-0"><a href="#SH-1-0" class="headerlink" title="SH[1:0]:"></a>SH[1:0]:</h5><p><code>#define PTE_SHARED		(_AT(pteval_t, 3) &lt;&lt; 8)		/* SH[1:0], inner shareable */</code><br>这个页表属性可以设置为以下几种：</p>
<ul>
<li><p>00: 非共享 (Non-shareable)。<br>内存区域只对一个处理器可见<br>其他处理器不会看到对该区域的更改</p>
</li>
<li><p>01: 保留值</p>
</li>
<li><p>10: 外部共享 (Outer shareable)。<br>内存区域对特定”外部共享域”中的所有处理器可见<br>通常包括集群外的处理器</p>
</li>
<li><p>11: 内部共享 (Inner shareable)。<br>内存区域对”内部共享域”中的所有处理器可见，通常指同一集群内的处理器</p>
</li>
</ul>
<p>PTE_SHARED 设置为内部共享（值为 3）意味着页表的内存在同一处理器集群内的所有核心之间保持一致，当一个CPU修改该页表时，其他CPU会看到这些更改。缓存一致性协议会确保所有CPU能够看到相同的页表内容。</p>
<h5 id="AP-2-1"><a href="#AP-2-1" class="headerlink" title="AP[2:1]:"></a>AP[2:1]:</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_USER		(_AT(pteval_t, 1) &lt;&lt; 6)		<span class="comment">/* AP[1] */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_RDONLY		(_AT(pteval_t, 1) &lt;&lt; 7)		<span class="comment">/* AP[2] */</span></span></span><br></pre></td></tr></table></figure>

<p>AP[2]的作用：</p>
<ul>
<li>AP[2] &#x3D; 1 表示全局只读（内核态用户态均不可写）。内核态用户态都是，无论AP[1]设置什么值。</li>
<li>AP[2] &#x3D; 0 表示内核态可写。但用户态是否可写还得看AP[1]。</li>
</ul>
<p>AP[1]的作用：</p>
<ul>
<li>AP[1] &#x3D; 0 表示用户态可访问</li>
<li>AP[1] &#x3D; 1 表示用户态不可访问</li>
</ul>
<p>要控制内核态和用户态的内存访问属性，这两个值要配合，例如：</p>
<ol>
<li>用户态读写：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pte_val |= PTE_USER;    <span class="comment">// AP[1]=1（用户态可访问）</span></span><br><span class="line">pte_val &amp;= ~PTE_RDONLY; <span class="comment">// AP[2]=0（允许写入）</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>用户态只读</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pte_val |= PTE_USER;    <span class="comment">// AP[1]=1（用户态可访问）</span></span><br><span class="line">pte_val |= PTE_RDONLY;  <span class="comment">// AP[2]=1（全局只读）</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>内核私有只读页</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pte_val &amp;= ~PTE_USER;   <span class="comment">// AP[1]=0（用户态不可访问）</span></span><br><span class="line">pte_val |= PTE_RDONLY;  <span class="comment">// AP[2]=1（全局只读）</span></span><br></pre></td></tr></table></figure>

<h5 id="Attrindx-2-0"><a href="#Attrindx-2-0" class="headerlink" title="Attrindx[2:0]:"></a>Attrindx[2:0]:</h5><p>这个就是内存属性了，mmu会拿这个值与上述的MAIR_xx寄存器保存的值进行对比，确定内存属性。</p>
<p>内存属性需要注意的地方：</p>
<ul>
<li>device属性访问：<br>在内核中，例如ioremap一段预留内存的时候设置的属性就是Device属性的。device属性的内存是不允许随机访问的（比如读写汇聚等），在ARM架构下，Device属性内存读写不能使用memset，memcpy等方式读写的，会导致内核挂死。Device属性内存读写需要使用memset_io等带_io的接口组去访问的。</li>
</ul>
<h5 id="BIT-58-55"><a href="#BIT-58-55" class="headerlink" title="BIT[58:55]"></a>BIT[58:55]</h5><p>BIT 58-55被标记位是Reserved For Softwre Use，是用来记录OS信息的。例如Linux的PTE_DIRTY标记就是放到BIT 55。PTE_DIRTY表示page是不是已经被写了。<br>PTE_DIRTY是否被置，关系到后续Swap out流程中，是否要将内容同步到文件系统。如果没有置PTE_DIRTY，那种page就没有必要同步直接释放就好了。如果是被置的，那就需要先同步到文件系统再释放。</p>
<h3 id="页表-1"><a href="#页表-1" class="headerlink" title="页表"></a>页表</h3><p>上面也提到了，初始化阶段，会创建两个页表<code>init_idmap_pg_dir</code>和<code>init_pg_dir</code>。下面看一下这两个页表在初始化阶段是分别映射什么的。</p>
<h4 id="init-idmap-pg-dir"><a href="#init-idmap-pg-dir" class="headerlink" title="init_idmap_pg_dir"></a>init_idmap_pg_dir</h4><p>这个页表是在mmu打开之前建好页表并设置给TTBR0_EL1上的。</p>
<ol>
<li>创建页表<br><code>init_idmap_pg_dir</code>是<code>vmlinux.lds.S</code>链接文件里边定义的一段内存空间。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vmlinux.lds.S</span></span><br><span class="line">init_idmap_pg_dir = .;</span><br><span class="line">. += INIT_IDMAP_DIR_SIZE;</span><br><span class="line">init_idmap_pg_end = .;</span><br></pre></td></tr></table></figure>

<p>在<code>primary_entry</code>函数中创建页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SYM_CODE_START(primary_entry)</span><br><span class="line">	bl	record_mmu_state</span><br><span class="line">	bl	preserve_boot_args</span><br><span class="line"></span><br><span class="line">	adrp	x1, early_init_stack</span><br><span class="line">	mov	sp, x1</span><br><span class="line">	mov	x29, xzr</span><br><span class="line">	adrp	x0, init_idmap_pg_dir</span><br><span class="line">	mov	x1, xzr</span><br><span class="line">	bl	__pi_create_init_idmap</span><br></pre></td></tr></table></figure>

<p>真正创建页表是在<code>create_init_idmap</code>函数中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage u64 __init <span class="title function_">create_init_idmap</span><span class="params">(<span class="type">pgd_t</span> *pg_dir, <span class="type">pteval_t</span> clrmask)</span></span><br><span class="line">&#123;</span><br><span class="line">	u64 ptep = (u64)pg_dir + PAGE_SIZE;</span><br><span class="line">	<span class="type">pgprot_t</span> text_prot = PAGE_KERNEL_ROX;</span><br><span class="line">	<span class="type">pgprot_t</span> data_prot = PAGE_KERNEL;</span><br><span class="line"></span><br><span class="line">	pgprot_val(text_prot) &amp;= ~clrmask;</span><br><span class="line">	pgprot_val(data_prot) &amp;= ~clrmask;</span><br><span class="line"></span><br><span class="line">	map_range(&amp;ptep, (u64)_stext, (u64)__initdata_begin, (u64)_stext,</span><br><span class="line">		  text_prot, IDMAP_ROOT_LEVEL, (<span class="type">pte_t</span> *)pg_dir, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">	map_range(&amp;ptep, (u64)__initdata_begin, (u64)_end, (u64)__initdata_begin,</span><br><span class="line">		  data_prot, IDMAP_ROOT_LEVEL, (<span class="type">pte_t</span> *)pg_dir, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ptep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>create_init_idmap</code>函数中国可以看到，<code>init_idmap_pg_dir</code>页表中，会将代码段和数据段分别使用不同的属性映射（<code>PAGE_KERNEL_ROX</code>和<code>PAGE_KERNEL</code>）。<br>页表是一一映射的。</p>
<h4 id="init-pg-dir"><a href="#init-pg-dir" class="headerlink" title="init_pg_dir"></a>init_pg_dir</h4><p><code>init_pg_dir</code>页表是加载到TTBR1_EL1上的。这个页表也是在<code>vmlinux.lds.S</code>中定义的一段区域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vmlinux.lds.S</span></span><br><span class="line">. = ALIGN(PAGE_SIZE);</span><br><span class="line">init_pg_dir = .;</span><br><span class="line">. += INIT_DIR_SIZE;</span><br><span class="line">init_pg_end = .;</span><br></pre></td></tr></table></figure>
<p><code>init_pg_dir</code>初始化在下面的<code>early_map_kernel</code>函数中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SYM_FUNC_START_LOCAL(__primary_switch)</span><br><span class="line">	adrp	x1, reserved_pg_dir</span><br><span class="line">	adrp	x2, init_idmap_pg_dir</span><br><span class="line">	bl	__enable_mmu</span><br><span class="line"></span><br><span class="line">	adrp	x1, early_init_stack</span><br><span class="line">	mov	sp, x1</span><br><span class="line">	mov	x29, xzr</span><br><span class="line">	mov	x0, x20				<span class="comment">// pass the full boot status</span></span><br><span class="line">	mov	x1, x21				<span class="comment">// pass the FDT</span></span><br><span class="line">	bl	__pi_early_map_kernel		<span class="comment">// Map and relocate the kernel</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> __init <span class="title function_">early_map_kernel</span><span class="params">(u64 boot_status, <span class="type">void</span> *fdt)</span></span><br><span class="line">&#123;</span><br><span class="line">	va_base = KIMAGE_VADDR + kaslr_offset;</span><br><span class="line">	map_kernel(kaslr_offset, va_base - pa_base, root_level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到映射已经不是一一映射了，会将物理地址映射给<code>KIMAGE_VADDR</code>开始的地址。这个地址是MODULE_END开始的（MODULE_END地址查看内存模型篇<a href="https://ray-jk-hong.github.io/blog/2025/04/07/linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%EF%BC%89%E3%80%82">https://ray-jk-hong.github.io/blog/2025/04/07/linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/）。</a></p>
<h2 id="页表翻译过程"><a href="#页表翻译过程" class="headerlink" title="页表翻译过程"></a>页表翻译过程</h2><p>下面是一个64kB页粒度，42位虚拟地址空间的翻译过程。一页64kB(2^16)，每一个页表项8B(2^3)，即每个页表2^13项&#x3D;8192项。因而VA的每13位用于页表项的索引，13位、13位、16位。</p>
<img src="/blog/2025/07/22/arch/Arm-mmu/%E5%AF%BB%E5%9D%80%E8%BF%87%E7%A8%8B-01.png" class="" title="图片描述">

<p>如上图所示、寻址过程如下：</p>
<ul>
<li>通过VA的最前面的比特位、确定是访问TTBR0还是方式TTBR1、确定完访问并拿到TTBRx中保存的物理地址。</li>
<li>通过TTBRx的物理地址即Level2的地址加上VA中的<code>[41:29]</code>作为偏移、可以找到Level2中的Table Descriptor。</li>
<li>通过Level2中的Table Descriptor内容中的地址、可以拿到Level3页表的物理地址</li>
<li>通过Level3物理地址加上VA的<code>[28:26]</code>作为偏移、可以拿到Level3的Table Descriptor。</li>
<li>Level3的Table Descriptor中的内容作为PA的<code>[47:16]</code>加上VA的<code>[15:0]</code>作为PA的<code>[15:0]</code>、就可以拿到真正的PA了。</li>
</ul>
<p>Level2&#x2F;Level3中的内容就是页表描述符、有以下几种：</p>
<ul>
<li>Table Descriptor ： 查找下一级页表</li>
<li>BLock Entry：寻址就到这一级、不会继续寻址。通常大页等场景会使用</li>
<li>Table Entry：就是寻址到了最后一级、就会是这种</li>
<li>Invalid enry：显示页表无效、除了没有建页表等异常场景、Swap等正常的场景也会使用到</li>
</ul>
<p>如下图所示：</p>
<img src="/blog/2025/07/22/arch/Arm-mmu/%E5%AF%BB%E5%9D%80%E8%BF%87%E7%A8%8B-02.png" class="" title="图片描述">

<h3 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h3><p>ESR_ELx</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ray-jk-hong.github.io">ray.jk.hong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ray-jk-hong.github.io/2025/07/22/arch/Arm-mmu/">https://ray-jk-hong.github.io/2025/07/22/arch/Arm-mmu/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ray-jk-hong.github.io" target="_blank">ray.jk.hong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/%E8%8A%AF%E7%89%87%E6%9E%B6%E6%9E%84/">芯片架构</a></div><div class="post-share"><div class="social-share" data-image="/blog/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/blog/2025/07/22/arch/ARM-SMMU-V3/" title="ARM-SMMU-V3"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">ARM-SMMU-V3</div></div><div class="info-2"><div class="info-item-1">介绍MMU是给CPU转地址的，那IOMMU就是给设备转地址的。   IOMMU地址翻译IOMMU本质就是给Device做地址翻译。IOMMU是通过以下流程找的。 页表建立确定地址翻译等级在地址翻译过程中，Device除了携带iova之外，每个Device都会有一个或者若干个Stream Id。第一步就是通过Stream Id找到STE。Stream Id是某个设备的固有的识别标志。SMMU通过Stream Id识别不同的设备，进行设备的隔离。Stream Id的最大值是 1 &lt;&lt; SMMU_IDR1.SIDSIZE。 一维的翻译过程：   一维的翻译过程是通过STRTAB_BASE + sid * 64（一个STE的大小为64B）找到STE。 二维的翻译过程：二维查找，Stream Id被分为两段，其分割点是设置在SMMU_STRTAB_BASE_CFG.SPLIT中。   如上图所示，假设Stream Id最高位是9，SPLIT是8，则翻译过程是先通过sid的高位找到L1_STD（STRTAB_BASE + sid[9:8] * 8,...</div></div></div></a><a class="pagination-related" href="/blog/2025/07/22/arch/Cache/" title="Cache架构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Cache架构</div></div><div class="info-2"><div class="info-item-1">内存层次典型的ARM CPU存储系统CPU与主存之间有几层Cache用于缓存   不同层级的Cache数据共享不同：  一个CPU core独享L1 Cache，不与其他CPU core共享 Cluster内部，CPU core之间共享L2 Cache 不同Cluster或者外设之间，只共享L3 Cache  不同层级的Cache访问效率不同：   Cache与MMU&#x2F;TLB  在支持虚拟地址的芯片，Cache可以处于不同的位置，分成以下两种  Logical Cache（Virtual Cache）：Cache处于CPU和MMU之间 Physical Cache：Cache处于MMU和主存之间  Cache架构Cache基本结构Cache Memory简单的Cache内存如下所示，由三个部分组成：  Directory store（Cache-tag）：Cache数量极为有限，需要根据地址进行换算找到对应的Cache-tag并进行访问。 Data Section：保存主存的数据内容，一般大小称之为Cache line大小。（当前看到的一般为64个字节） Status...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/blog/2025/07/22/arch/ARM-SMMU-V3/" title="ARM-SMMU-V3"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-22</div><div class="info-item-2">ARM-SMMU-V3</div></div><div class="info-2"><div class="info-item-1">介绍MMU是给CPU转地址的，那IOMMU就是给设备转地址的。   IOMMU地址翻译IOMMU本质就是给Device做地址翻译。IOMMU是通过以下流程找的。 页表建立确定地址翻译等级在地址翻译过程中，Device除了携带iova之外，每个Device都会有一个或者若干个Stream Id。第一步就是通过Stream Id找到STE。Stream Id是某个设备的固有的识别标志。SMMU通过Stream Id识别不同的设备，进行设备的隔离。Stream Id的最大值是 1 &lt;&lt; SMMU_IDR1.SIDSIZE。 一维的翻译过程：   一维的翻译过程是通过STRTAB_BASE + sid * 64（一个STE的大小为64B）找到STE。 二维的翻译过程：二维查找，Stream Id被分为两段，其分割点是设置在SMMU_STRTAB_BASE_CFG.SPLIT中。   如上图所示，假设Stream Id最高位是9，SPLIT是8，则翻译过程是先通过sid的高位找到L1_STD（STRTAB_BASE + sid[9:8] * 8,...</div></div></div></a><a class="pagination-related" href="/blog/2025/07/22/arch/Cache/" title="Cache架构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-22</div><div class="info-item-2">Cache架构</div></div><div class="info-2"><div class="info-item-1">内存层次典型的ARM CPU存储系统CPU与主存之间有几层Cache用于缓存   不同层级的Cache数据共享不同：  一个CPU core独享L1 Cache，不与其他CPU core共享 Cluster内部，CPU core之间共享L2 Cache 不同Cluster或者外设之间，只共享L3 Cache  不同层级的Cache访问效率不同：   Cache与MMU&#x2F;TLB  在支持虚拟地址的芯片，Cache可以处于不同的位置，分成以下两种  Logical Cache（Virtual Cache）：Cache处于CPU和MMU之间 Physical Cache：Cache处于MMU和主存之间  Cache架构Cache基本结构Cache Memory简单的Cache内存如下所示，由三个部分组成：  Directory store（Cache-tag）：Cache数量极为有限，需要根据地址进行换算找到对应的Cache-tag并进行访问。 Data Section：保存主存的数据内容，一般大小称之为Cache line大小。（当前看到的一般为64个字节） Status...</div></div></div></a><a class="pagination-related" href="/blog/2025/07/28/arch/Arm%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/" title="arm原子操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-28</div><div class="info-item-2">arm原子操作</div></div><div class="info-2"><div class="info-item-1">通过ll&#x2F;sc实现在ARMv6以上（含v6）构架有了多核的CPU。为了在多核之间同步数据和控制并发、ARM在内存访问上增加了独占监测（Exclusive monitors）机制、并增加了相关的指令。ll(load-link)指令、sc(store-condition)指令。ll对应的arm指令是ldaxr、sc对应的arm指令是stlxr。进行原子操作的大致流程如下：  使用 LDXR (Load-Exclusive) 指令加载数据到寄存器，同时标记对应的内存地址为独占状态。 在寄存器中进行数据修改。 使用 STXR (Store-Conditional) 指令尝试将修改后的数据写回内存。如果该内存区域在 LDXR 和 STXR 之间没有被其他处理器修改，STXR 将返回成功，并且独占状态会被清除；如果被修改过，STXR 将失败，需要回到第一步重新尝试。  ﻿ 下面看看atomic_add是怎么通过ll&#x2F;sc指令完成原子加操作的： 1234567891011121314static inline void atomic_add(int i, atomic_t...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/blog/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">ray.jk.hong</div><div class="author-info-description"></div><div class="site-data"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ray-jk-hong"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E9%85%8D%E7%BD%AE"><span class="toc-number">1.</span> <span class="toc-text">启动阶段配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCR-EL%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">TCR_EL寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TxSZ%EF%BC%88%E6%9C%89T0SZ-T1SZ%E4%B8%A4%E4%B8%AA%EF%BC%8C%E7%BB%9F%E4%B8%80%E8%A1%A8%E7%A4%BA%E4%B8%BATxSZ%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">TxSZ（有T0SZ&#x2F;T1SZ两个，统一表示为TxSZ）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IPS-Intermediate-Physical-Address-Size"><span class="toc-number">1.1.2.</span> <span class="toc-text">IPS(Intermediate Physical Address Size)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TGx%EF%BC%88TG0-TG1%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">TGx（TG0&#x2F;TG1）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ORGNx-IRGNx"><span class="toc-number">1.1.4.</span> <span class="toc-text">ORGNx, IRGNx</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SHx"><span class="toc-number">1.1.5.</span> <span class="toc-text">SHx</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AS"><span class="toc-number">1.1.6.</span> <span class="toc-text">AS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#A1"><span class="toc-number">1.1.7.</span> <span class="toc-text">A1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCR%E4%B8%AD54bit"><span class="toc-number">1.1.8.</span> <span class="toc-text">TCR中54bit</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TBI1-TBID1-TBID1%E4%B8%8A%E9%9D%A2%E7%9A%84%E5%9B%BE%E4%B8%AD%E6%B2%A1%E6%9C%89%EF%BC%8C%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%98%AF%E4%BF%9D%E5%AD%98%E5%9C%A852bit"><span class="toc-number">1.1.9.</span> <span class="toc-text">TBI1, TBID1 (TBID1上面的图中没有，代码中是保存在52bit)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TBI0"><span class="toc-number">1.1.10.</span> <span class="toc-text">TBI0</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HD"><span class="toc-number">1.1.11.</span> <span class="toc-text">HD</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HA"><span class="toc-number">1.1.12.</span> <span class="toc-text">HA</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MAIR-ELn"><span class="toc-number">1.2.</span> <span class="toc-text">MAIR_ELn</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TTBCR"><span class="toc-number">1.3.</span> <span class="toc-text">TTBCR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TTBR0-EL1-TTBR1-EL1"><span class="toc-number">1.4.</span> <span class="toc-text">TTBR0_EL1, TTBR1_EL1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SCTLR-EL1"><span class="toc-number">1.5.</span> <span class="toc-text">SCTLR_EL1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%B1%82%E7%BA%A7"><span class="toc-number">2.1.</span> <span class="toc-text">页表的层级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">页表的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">2.3.</span> <span class="toc-text">页表属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#UXN-XN-%E7%BD%AE1%E8%A1%A8%E7%A4%BA%E7%94%A8%E6%88%B7%E6%80%81%E6%B2%A1%E6%9C%89%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90%E3%80%82"><span class="toc-number">2.3.1.</span> <span class="toc-text">UXN&#x2F;XN: 置1表示用户态没有执行权限。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PXN-%E7%BD%AE1%E8%A1%A8%E7%A4%BA%E5%86%85%E6%A0%B8%E6%80%81%E6%B2%A1%E6%9C%89%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90%E3%80%82"><span class="toc-number">2.3.2.</span> <span class="toc-text">PXN: 置1表示内核态没有执行权限。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Contiguous"><span class="toc-number">2.3.3.</span> <span class="toc-text">Contiguous:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#nG"><span class="toc-number">2.3.4.</span> <span class="toc-text">nG:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AF-%E8%AE%B0%E5%BD%95%E6%98%AF%E5%90%A6%E8%A2%AB%E8%AE%BF%E9%97%AE%E8%BF%87%E3%80%820%E8%A1%A8%E7%A4%BA%E5%B0%9A%E6%9C%AA%E8%A2%AB%E8%AE%BF%E9%97%AE%EF%BC%8C1%E8%A1%A8%E7%A4%BA%E5%B7%B2%E7%BB%8F%E8%A2%AB%E8%AE%BF%E9%97%AE%E4%BA%86%E3%80%82"><span class="toc-number">2.3.5.</span> <span class="toc-text">AF: 记录是否被访问过。0表示尚未被访问，1表示已经被访问了。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DBM-51"><span class="toc-number">2.3.6.</span> <span class="toc-text">DBM[51]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SH-1-0"><span class="toc-number">2.3.7.</span> <span class="toc-text">SH[1:0]:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AP-2-1"><span class="toc-number">2.3.8.</span> <span class="toc-text">AP[2:1]:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Attrindx-2-0"><span class="toc-number">2.3.9.</span> <span class="toc-text">Attrindx[2:0]:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BIT-58-55"><span class="toc-number">2.3.10.</span> <span class="toc-text">BIT[58:55]</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8-1"><span class="toc-number">3.</span> <span class="toc-text">页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#init-idmap-pg-dir"><span class="toc-number">3.1.</span> <span class="toc-text">init_idmap_pg_dir</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init-pg-dir"><span class="toc-number">3.2.</span> <span class="toc-text">init_pg_dir</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%BF%BB%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">页表翻译过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5"><span class="toc-number">1.</span> <span class="toc-text">缺页</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>