<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>riscv寄存器 | ray.jk.hong</title><meta name="robots" content="noindex"><meta name="author" content="ray.jk.hong"><meta name="copyright" content="ray.jk.hong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="通用寄存器riscv有32个64位通用寄存器x0-x31。    寄存器 ABI名称 描述 调用约定    x0 zero 硬编码零 始终为0,写入无效   x1 ra 返回地址 调用者保存   x2 sp 栈指针 被调用者保存   x3 gp 全局指针    x4 tp 线程指针    x5 t0 临时寄存器 调用者保存   x6 t1 临时寄存器 调用者保存   x7 t2 临时寄存器 调用者">
<meta property="og:type" content="article">
<meta property="og:title" content="riscv寄存器">
<meta property="og:url" content="https://ray-jk-hong.github.io/2025/11/08/arch/riscv/riscv%E5%AF%84%E5%AD%98%E5%99%A8/index.html">
<meta property="og:site_name" content="ray.jk.hong">
<meta property="og:description" content="通用寄存器riscv有32个64位通用寄存器x0-x31。    寄存器 ABI名称 描述 调用约定    x0 zero 硬编码零 始终为0,写入无效   x1 ra 返回地址 调用者保存   x2 sp 栈指针 被调用者保存   x3 gp 全局指针    x4 tp 线程指针    x5 t0 临时寄存器 调用者保存   x6 t1 临时寄存器 调用者保存   x7 t2 临时寄存器 调用者">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ray-jk-hong.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-11-08T02:25:14.566Z">
<meta property="article:modified_time" content="2025-11-08T02:25:14.566Z">
<meta property="article:author" content="ray.jk.hong">
<meta property="article:tag" content="芯片架构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ray-jk-hong.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "riscv寄存器",
  "url": "https://ray-jk-hong.github.io/2025/11/08/arch/riscv/riscv%E5%AF%84%E5%AD%98%E5%99%A8/",
  "image": "https://ray-jk-hong.github.io/img/butterfly-icon.png",
  "datePublished": "2025-11-08T02:25:14.566Z",
  "dateModified": "2025-11-08T02:25:14.566Z",
  "author": [
    {
      "@type": "Person",
      "name": "ray.jk.hong",
      "url": "https://ray-jk-hong.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="https://ray-jk-hong.github.io/2025/11/08/arch/riscv/riscv%E5%AF%84%E5%AD%98%E5%99%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'riscv寄存器',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="/js/bandev.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/blog/"></a><a class="nav-page-title" href="/blog/"><span class="site-name">riscv寄存器</span></a></span><div id="menus"></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">riscv寄存器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-categories"><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/linux/">linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>riscv有32个64位通用寄存器x0-x31。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>ABI名称</th>
<th>描述</th>
<th>调用约定</th>
</tr>
</thead>
<tbody><tr>
<td><strong>x0</strong></td>
<td><strong>zero</strong></td>
<td>硬编码零</td>
<td>始终为0,写入无效</td>
</tr>
<tr>
<td><strong>x1</strong></td>
<td><strong>ra</strong></td>
<td>返回地址</td>
<td>调用者保存</td>
</tr>
<tr>
<td><strong>x2</strong></td>
<td><strong>sp</strong></td>
<td>栈指针</td>
<td>被调用者保存</td>
</tr>
<tr>
<td><strong>x3</strong></td>
<td><strong>gp</strong></td>
<td>全局指针</td>
<td></td>
</tr>
<tr>
<td><strong>x4</strong></td>
<td><strong>tp</strong></td>
<td>线程指针</td>
<td></td>
</tr>
<tr>
<td><strong>x5</strong></td>
<td><strong>t0</strong></td>
<td>临时寄存器</td>
<td>调用者保存</td>
</tr>
<tr>
<td><strong>x6</strong></td>
<td><strong>t1</strong></td>
<td>临时寄存器</td>
<td>调用者保存</td>
</tr>
<tr>
<td><strong>x7</strong></td>
<td><strong>t2</strong></td>
<td>临时寄存器</td>
<td>调用者保存</td>
</tr>
<tr>
<td><strong>x8</strong></td>
<td><strong>s0&#x2F;fp</strong></td>
<td>保存寄存器&#x2F;帧指针</td>
<td>被调用者保存</td>
</tr>
<tr>
<td><strong>x9</strong></td>
<td><strong>s1</strong></td>
<td>保存寄存器</td>
<td>被调用者保存</td>
</tr>
<tr>
<td><strong>x10</strong></td>
<td><strong>a0</strong></td>
<td>函数参数&#x2F;返回值</td>
<td>调用者保存</td>
</tr>
<tr>
<td><strong>x11</strong></td>
<td><strong>a1</strong></td>
<td>函数参数&#x2F;返回值</td>
<td>调用者保存</td>
</tr>
<tr>
<td><strong>x12</strong></td>
<td><strong>a2</strong></td>
<td>函数参数</td>
<td>调用者保存</td>
</tr>
<tr>
<td><strong>x13</strong></td>
<td><strong>a3</strong></td>
<td>函数参数</td>
<td>调用者保存</td>
</tr>
<tr>
<td><strong>x14</strong></td>
<td><strong>a4</strong></td>
<td>函数参数</td>
<td>调用者保存</td>
</tr>
<tr>
<td><strong>x15</strong></td>
<td><strong>a5</strong></td>
<td>函数参数</td>
<td>调用者保存</td>
</tr>
<tr>
<td><strong>x16</strong></td>
<td><strong>a6</strong></td>
<td>函数参数</td>
<td>调用者保存</td>
</tr>
<tr>
<td><strong>x17</strong></td>
<td><strong>a7</strong></td>
<td>函数参数</td>
<td>调用者保存</td>
</tr>
<tr>
<td><strong>x18</strong></td>
<td><strong>s2</strong></td>
<td>保存寄存器</td>
<td>被调用者保存</td>
</tr>
<tr>
<td><strong>x19</strong></td>
<td><strong>s3</strong></td>
<td>保存寄存器</td>
<td>被调用者保存</td>
</tr>
<tr>
<td><strong>x20</strong></td>
<td><strong>s4</strong></td>
<td>保存寄存器</td>
<td>被调用者保存</td>
</tr>
<tr>
<td><strong>x21</strong></td>
<td><strong>s5</strong></td>
<td>保存寄存器</td>
<td>被调用者保存</td>
</tr>
<tr>
<td><strong>x22</strong></td>
<td><strong>s6</strong></td>
<td>保存寄存器</td>
<td>被调用者保存</td>
</tr>
<tr>
<td><strong>x23</strong></td>
<td><strong>s7</strong></td>
<td>保存寄存器</td>
<td>被调用者保存</td>
</tr>
<tr>
<td><strong>x24</strong></td>
<td><strong>s8</strong></td>
<td>保存寄存器</td>
<td>被调用者保存</td>
</tr>
<tr>
<td><strong>x25</strong></td>
<td><strong>s9</strong></td>
<td>保存寄存器</td>
<td>被调用者保存</td>
</tr>
<tr>
<td><strong>x26</strong></td>
<td><strong>s10</strong></td>
<td>保存寄存器</td>
<td>被调用者保存</td>
</tr>
<tr>
<td><strong>x27</strong></td>
<td><strong>s11</strong></td>
<td>保存寄存器</td>
<td>被调用者保存</td>
</tr>
<tr>
<td><strong>x28</strong></td>
<td><strong>t3</strong></td>
<td>临时寄存器</td>
<td>调用者保存</td>
</tr>
<tr>
<td><strong>x29</strong></td>
<td><strong>t4</strong></td>
<td>临时寄存器</td>
<td>调用者保存</td>
</tr>
<tr>
<td><strong>x30</strong></td>
<td><strong>t5</strong></td>
<td>临时寄存器</td>
<td>调用者保存</td>
</tr>
<tr>
<td><strong>x31</strong></td>
<td><strong>t6</strong></td>
<td>临时寄存器</td>
<td>调用者保存</td>
</tr>
</tbody></table>
<h2 id="状态控制寄存器CSR"><a href="#状态控制寄存器CSR" class="headerlink" title="状态控制寄存器CSR"></a>状态控制寄存器CSR</h2><h3 id="M-mode"><a href="#M-mode" class="headerlink" title="M-mode"></a>M-mode</h3><table>
<thead>
<tr>
<th>CSR 地址</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0x300</td>
<td><strong>mstatus</strong></td>
<td>机器状态寄存器</td>
</tr>
<tr>
<td>0x301</td>
<td><strong>misa</strong></td>
<td>机器 ISA 信息</td>
</tr>
<tr>
<td>0x304</td>
<td><strong>mie</strong></td>
<td>机器中断使能</td>
</tr>
<tr>
<td>0x305</td>
<td><strong>mtvec</strong></td>
<td>机器陷阱向量基地址</td>
</tr>
<tr>
<td>0x340</td>
<td><strong>mscratch</strong></td>
<td>机器临时寄存器</td>
</tr>
<tr>
<td>0x341</td>
<td><strong>mepc</strong></td>
<td>机器异常程序计数器</td>
</tr>
<tr>
<td>0x342</td>
<td><strong>mcause</strong></td>
<td>机器异常原因</td>
</tr>
<tr>
<td>0x343</td>
<td><strong>mtval</strong></td>
<td>机器陷阱值</td>
</tr>
<tr>
<td>0x344</td>
<td><strong>mip</strong></td>
<td>机器中断等待</td>
</tr>
</tbody></table>
<h3 id="S-mode"><a href="#S-mode" class="headerlink" title="S-mode"></a>S-mode</h3><table>
<thead>
<tr>
<th>CSR 地址</th>
<th>名称</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>0x100</strong></td>
<td><strong>sstatus</strong></td>
<td>64</td>
<td>S-mode 状态寄存器</td>
</tr>
<tr>
<td><strong>0x104</strong></td>
<td><strong>sie</strong></td>
<td>64</td>
<td>S-mode 中断使能寄存器</td>
</tr>
<tr>
<td><strong>0x105</strong></td>
<td><strong>stvec</strong></td>
<td>64</td>
<td>S-mode 陷阱向量基地址寄存器</td>
</tr>
<tr>
<td><strong>0x106</strong></td>
<td><strong>scounteren</strong></td>
<td>32</td>
<td>S-mode 计数器使能寄存器</td>
</tr>
<tr>
<td><strong>0x140</strong></td>
<td><strong>sscratch</strong></td>
<td>64</td>
<td>S-mode 临时寄存器</td>
</tr>
<tr>
<td><strong>0x141</strong></td>
<td><strong>sepc</strong></td>
<td>64</td>
<td>S-mode 异常程序计数器</td>
</tr>
<tr>
<td><strong>0x142</strong></td>
<td><strong>scause</strong></td>
<td>64</td>
<td>S-mode 异常原因寄存器</td>
</tr>
<tr>
<td><strong>0x143</strong></td>
<td><strong>stval</strong></td>
<td>64</td>
<td>S-mode 陷阱值寄存器</td>
</tr>
<tr>
<td><strong>0x144</strong></td>
<td><strong>sip</strong></td>
<td>64</td>
<td>S-mode 中断等待寄存器</td>
</tr>
</tbody></table>
<h4 id="scause-Supervisor-Cause"><a href="#scause-Supervisor-Cause" class="headerlink" title="scause (Supervisor Cause)"></a>scause (Supervisor Cause)</h4><p>scause寄存器：</p>


<p>上图中寄存器分为interrup和exception code两种。interrupt表示陷入到S-mode是否是中断引起的。exception code表示具体原因。</p>
<p>根据不同场景，具体的exception code值表示的意义如下：</p>


<h4 id="sepc-Supervisor-Exception-Program-Counter"><a href="#sepc-Supervisor-Exception-Program-Counter" class="headerlink" title="sepc (Supervisor Exception Program Counter)"></a>sepc (Supervisor Exception Program Counter)</h4><p>在陷入S-mode时，sepc寄存器会被写入被中断或遇到异常的指令的虚拟地址。sepc系统调用返回时用于恢复。<br>当S-mode处理完调用sret时，会跳转回这个地址。</p>
<h4 id="stvec（Supervisor-Trap-Vector-Base-Address）"><a href="#stvec（Supervisor-Trap-Vector-Base-Address）" class="headerlink" title="stvec（Supervisor Trap Vector Base Address）"></a>stvec（Supervisor Trap Vector Base Address）</h4><p>设置 S-mode异常处理程序的入口地址。</p>


<p>上图中，BASE部分保存异常处理程序入口的地址，地址必须是4字节对齐。</p>
<p>MODE部分根据其值有不同的解释，如下图所示：</p>


<p>0表示Direct模式，所有异常跳转到BASE。<br>1表示Vectored模式，同步异常跳转到 BASE，中断跳转到 BASE + 4 × cause。</p>
<h4 id="sie-sip-Supervisor-Interrupt"><a href="#sie-sip-Supervisor-Interrupt" class="headerlink" title="sie &amp; sip (Supervisor Interrupt)"></a>sie &amp; sip (Supervisor Interrupt)</h4><p>sip：中断等待寄存器，显示当前等待处理的中断</p>


<ul>
<li>SSIP：S-mode 软件中断等待</li>
<li>STIP: S-mode 定时器中断等待</li>
<li>SEIP: S-mode 外部中断等待</li>
</ul>
<p>sie: 中断使能寄存器, 控制哪些中断在 S-mode下被使能</p>


<ul>
<li>SSIE: 软件中断使能 (software interrupt)</li>
<li>STIE: 定时器中断使能 (timer interrupt)</li>
<li>SEIE:  外部中断使能 (external interrupt)</li>
</ul>
<h4 id="satp（Supervisor-Address-Translation-and-Protection）"><a href="#satp（Supervisor-Address-Translation-and-Protection）" class="headerlink" title="satp（Supervisor Address Translation and Protection）"></a>satp（Supervisor Address Translation and Protection）</h4><p>地址转换和保护寄存器。</p>


<p>MODE表示页表转换模式:</p>


<ul>
<li>0：表示没有页表，直接使用物理地址</li>
<li>8：Sv39，表示使用39位虚拟地址</li>
<li>9：Sv48，表示使用48位虚拟地址</li>
</ul>
<p>ASID：保存地址空间标识符<br>PPN：保存根页表的物理页号</p>
<h4 id="sstatus（Supervisor-Status）"><a href="#sstatus（Supervisor-Status）" class="headerlink" title="sstatus（Supervisor Status）"></a>sstatus（Supervisor Status）</h4><p>sstatus跟踪当前处理器状态。</p>


<p>SPP：<br>表示了在进入S-mode之前的特权级别。0表示之前处于U-mode，1表示之前就属于S-mode。SPP用于在sret指令从异常返回时，决定返回到哪个特权级别，是实现特权级切换的关键机制。</p>
<p>SIE：负责使能或者去使能S-mode中的所有中断。当U-mode在执行的时候SIE位被忽略且S-mode中断被使能。在S-mode可以使用sie寄存器去使能或者去使能特定的中断类型。</p>
<p>SPIE：表示在进入S-mode之前SIE的值。</p>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ray-jk-hong.github.io">ray.jk.hong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ray-jk-hong.github.io/2025/11/08/arch/riscv/riscv%E5%AF%84%E5%AD%98%E5%99%A8/">https://ray-jk-hong.github.io/2025/11/08/arch/riscv/riscv%E5%AF%84%E5%AD%98%E5%99%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ray-jk-hong.github.io" target="_blank">ray.jk.hong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/%E8%8A%AF%E7%89%87%E6%9E%B6%E6%9E%84/">芯片架构</a></div><div class="post-share"><div class="social-share" data-image="/blog/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/blog/2025/07/22/arch/ARM-SMMU-V3/" title="ARM-SMMU-V3"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-22</div><div class="info-item-2">ARM-SMMU-V3</div></div><div class="info-2"><div class="info-item-1">介绍MMU是给CPU转地址的，那IOMMU就是给设备转地址的。   IOMMU地址翻译IOMMU本质就是给Device做地址翻译。IOMMU是通过以下流程找的。 页表建立确定地址翻译等级在地址翻译过程中，Device除了携带iova之外，每个Device都会有一个或者若干个Stream Id。第一步就是通过Stream Id找到STE。Stream Id是某个设备的固有的识别标志。SMMU通过Stream Id识别不同的设备，进行设备的隔离。Stream Id的最大值是 1 &lt;&lt; SMMU_IDR1.SIDSIZE。 一维的翻译过程：   一维的翻译过程是通过STRTAB_BASE + sid * 64（一个STE的大小为64B）找到STE。 二维的翻译过程：二维查找，Stream Id被分为两段，其分割点是设置在SMMU_STRTAB_BASE_CFG.SPLIT中。   如上图所示，假设Stream Id最高位是9，SPLIT是8，则翻译过程是先通过sid的高位找到L1_STD（STRTAB_BASE + sid[9:8] * 8,...</div></div></div></a><a class="pagination-related" href="/blog/2025/10/31/arch/Arm-mmu/" title="Arm-mmu"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-31</div><div class="info-item-2">Arm-mmu</div></div><div class="info-2"><div class="info-item-1">MMU负责将虚拟地址转成物理地址。除了地址转换，还可以控制一下几个事情：  内存访问权限控制 内存访问ordering控制 Cache访问策略下面就按照几个功能的来说明，并顺带说明没个功能所涉及的寄存器。  启动阶段配置在完成地址翻译的时候，在启动阶段要确认并配置以下几个寄存器。 TCR_EL寄存器  上图是TCR_EL寄存器的显示图。TCR寄存器的设置在arch/arm64/mm/proc.S的__cpu_setup函数中。 12345mov_q	tcr, TCR_TxSZ(VA_BITS) | TCR_CACHE_FLAGS | TCR_SMP_FLAGS | \		TCR_TG_FLAGS | TCR_KASLR_FLAGS | TCR_ASID16 | \		TCR_TBI0 | TCR_A1 | TCR_KASAN_SW_FLAGS | TCR_MTE_FLAGS   ...   tcr_compute_pa_size tcr, #TCR_IPS_SHIFT, x5,...</div></div></div></a><a class="pagination-related" href="/blog/2025/08/14/arch/Arm%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/" title="arm原子操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-14</div><div class="info-item-2">arm原子操作</div></div><div class="info-2"><div class="info-item-1">通过ll&#x2F;sc实现在ARMv6以上（含v6）构架有了多核的CPU。为了在多核之间同步数据和控制并发、ARM在内存访问上增加了独占监测（Exclusive monitors）机制、并增加了相关的指令。ll(load-link)指令、sc(store-condition)指令。ll对应的arm指令是ldaxr、sc对应的arm指令是stlxr。进行原子操作的大致流程如下：  使用 LDXR (Load-Exclusive) 指令加载数据到寄存器，同时标记对应的内存地址为独占状态。 在寄存器中进行数据修改。 使用 STXR (Store-Conditional) 指令尝试将修改后的数据写回内存。如果该内存区域在 LDXR 和 STXR 之间没有被其他处理器修改，STXR 将返回成功，并且独占状态会被清除；如果被修改过，STXR 将失败，需要回到第一步重新尝试。  ﻿ 下面看看atomic_add是怎么通过ll&#x2F;sc指令完成原子加操作的： 1234567891011121314static inline void atomic_add(int i, atomic_t...</div></div></div></a><a class="pagination-related" href="/blog/2025/10/17/arch/Cache/" title="Cache架构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-17</div><div class="info-item-2">Cache架构</div></div><div class="info-2"><div class="info-item-1">内存层次典型的ARM CPU存储系统CPU与主存之间有几层Cache用于缓存   不同层级的Cache数据共享不同：  一个CPU core独享L1 Cache，不与其他CPU core共享 Cluster内部，CPU core之间共享L2 Cache 不同Cluster或者外设之间，只共享L3 Cache  不同层级的Cache访问效率不同：   Cache与MMU&#x2F;TLB  在支持虚拟地址的芯片，Cache可以处于不同的位置，分成以下两种  Logical Cache（Virtual Cache）：Cache处于CPU和MMU之间 Physical Cache：Cache处于MMU和主存之间  Cache架构Cache基本结构Cache Memory简单的Cache内存如下所示，由三个部分组成：  Directory store（Cache-tag）：Cache数量极为有限，需要根据地址进行换算找到对应的Cache-tag并进行访问。 Data Section：保存主存的数据内容，一般大小称之为Cache line大小。（当前看到的一般为64个字节） Status...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/blog/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">ray.jk.hong</div><div class="author-info-description"></div><div class="site-data"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ray-jk-hong"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8CSR"><span class="toc-number">2.</span> <span class="toc-text">状态控制寄存器CSR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#M-mode"><span class="toc-number">2.1.</span> <span class="toc-text">M-mode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#S-mode"><span class="toc-number">2.2.</span> <span class="toc-text">S-mode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#scause-Supervisor-Cause"><span class="toc-number">2.2.1.</span> <span class="toc-text">scause (Supervisor Cause)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sepc-Supervisor-Exception-Program-Counter"><span class="toc-number">2.2.2.</span> <span class="toc-text">sepc (Supervisor Exception Program Counter)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stvec%EF%BC%88Supervisor-Trap-Vector-Base-Address%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">stvec（Supervisor Trap Vector Base Address）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sie-sip-Supervisor-Interrupt"><span class="toc-number">2.2.4.</span> <span class="toc-text">sie &amp; sip (Supervisor Interrupt)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#satp%EF%BC%88Supervisor-Address-Translation-and-Protection%EF%BC%89"><span class="toc-number">2.2.5.</span> <span class="toc-text">satp（Supervisor Address Translation and Protection）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sstatus%EF%BC%88Supervisor-Status%EF%BC%89"><span class="toc-number">2.2.6.</span> <span class="toc-text">sstatus（Supervisor Status）</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>